#!/bin/bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

if [ "$CUBE_DEBUG_SET_X_IF_SET" = 1 ] ; then
    set -x
fi

usage_start()
{
cat << EOF
 ${0##*/} start [--auto] <name>

    start (launch) a container:

       --auto=<name>: launch autostart containers tagged with <name>

       <name>: name of the container to be launched (if not "--auto")
EOF
}

usage_stop()
{
cat << EOF
 ${0##*/} stop <name>

    stop a container:

       <name>: name of the container to be stopped

EOF
}

usage_netprime()
{
cat << EOF
 ${0##*/} netprime <name>

    set container as the netprime:

       <name>: name of the container to be the netprime
EOF
}

usage_stack()
{
cat << EOF
 ${0##*/} stack <container a> <container b>

    stack (connect) two containers. This ensures that container a can communicate
    with container b via a defined port.

       <container a>: name of the first container and port to be stacked
       <container b>: name of the second container and port to be stacked
EOF
}
usage_store()
{
cat << EOF
 ${0##*/} store <container> <location>

    Put a container into storage. <location> is a directory or a registry (local
    or remote).

       <container>: name of the container to be stored
       <location>:  storage location. dir:// for directories, cube:// or docker:// for
                    registries.

EOF
}
usage_prep()
{
cat << EOF
 ${0##*/} prep <container>

    Execute any tweaks/prep against the specified container

EOF
}
usage_add()
{
cat << EOF
 ${0##*/} add [-n <name>] [-u <subuid>] <source>

    add a container to the platform. Once added, the container is monitored, but
    not started. Use "cube-ctl start" to launch a container after adding it.

       -n <name>: name of the container once added to the system. If this is
                  not supplied, the container source tarball is used to generate
                  a name.

       -u: make this newly added container unprivileged. The subuid field will
           be used to set the owner of the uid/gid in the root namespace for the
           newly added container. If no subuid field is provided, a default
           value of 800000 will be used.
 
       -o: if adding the container locally, the target directory for the rootfs

       -t: container type: lxc, oci or cube (default: oci)

       --auto=<name>: auto start the container, tag with <name>

       <source>: path to the container source. Either a directory or a tar.gz

EOF
}
usage_mv()
{
    usage_rename
}
usage_rename()
{
cat << EOF
 ${0##*/} rename <current name> <new name>
 ${0##*/} mv <current name> <new name>

    rename an existing container.

    Note 1: this stops the container, renames it, and restarts it if it was
            running.

    Note 2: this is an advanced command. If any other containers reference
            the original container by name, you may have future runtime problems.

    Note 3: currently restricted to 'oci' containers, to avoid system containers
            from being renamed (they are 'cubes')

EOF
}
usage_remove()
{
    usage_del
}
usage_delete()
{
    usage_del
}
usage_del()
{
cat << EOF
 ${0##*/} del [-F] <name>
 ${0##*/} delete [-F] <name>
 ${0##*/} remove [-F] <name>

    remove a container from the system. Once this completes, the container is
    stopped and purged from the filesystem.

       -F force remove container without prompting

  Note: only valid for 'oci' container types
  Note: container must be stopped before removing

EOF
}
usage_status()
{
cat << EOF
 ${0##*/} status
 ${0##*/} list

    list of known containers

EOF
}
usage_exec()
{
cat << EOF
 ${0##*/} [-i] <target>:<command>

    execute command <command> against a named target. Either a container
    name should be specified, or "host" for a native command.

      -i :    The command is interactive and a terminal should be allocated

EOF
}
usage_show()
{
    usage_info
}
usage_info()
{
cat << EOF
 ${0##*/} info <name>
 ${0##*/} show <name>

    display detailed information about container <name>

EOF
}

usage_global()
{
   output=$(mktemp)

cat << EOF > ${output}

 ${0##*/} <options> <cmd>

 commands (and options):
EOF

   usage_start >> ${output}
   usage_stop >> ${output}
   usage_netprime >> ${output}
   usage_stack >> ${output}
   usage_store >> ${output}
   usage_prep >> ${output}
   usage_add >> ${output}
   usage_rename >> ${output}
   usage_del >> ${output}
   usage_status >> ${output}
   usage_exec >> ${output}
   usage_info >> ${output}

   cat ${output} | less
   rm -f ${output}
}

if [ -z "$1" ]; then
    usage_global
    exit
fi

# take the entire command into an array
raw_command=($@)

force=""
non_dashed=""

if [ -z "${SBINDIR}" ]; then
    SBINDIR="/usr/sbin"
fi

# this corresponds to the lxc.id_map items within the container's config file
DEFAULT_SUBUID=800000

while [ $# -gt 0 ]; do
    case "$1" in
	-v|--verbose) verbose=t
            ;;
        --auto)
	    auto=${2}
	    shift
	    ;;
	--track)
	    track_containers=t
	    ;;
	-u)
	    # This is an unprivileged container. We need to config subuid/subgid.
	    if [ "${2}" -eq "${2}" ] 2>/dev/null; then
		if [ "${2}" -lt 100000 ] 2>/dev/null; then
		    echo "Error: -u requires a subuid number no less than 100000"
		    exit 1
		fi
		subuid="${2}"
		shift
	    else
		subuid="${DEFAULT_SUBUID}"
	    fi
	    ;;
	-F)
	    force=-F
	    ;;
        --n|-n)
	    container_name=${2}
	    shift
	    ;;
	--foreground|-f)
	    foreground=t
	    ;;
        --i|-i)
	    interactive=t
	    ;;
        --t|-t)
	    container_type=${2}
	    shift
	    ;;
        --o|-o)
	    out_dir=${2}
	    shift
	    ;;
	-h|--help)
	    cmd_help=${2}
	    if [ -z "${cmd_help}" ]; then
		usage_global
	    else
		f=$(type -t usage_${cmd_help})
		if [ "${f}" = "function" ]; then
		    usage_${cmd_help}
		else
		    echo "No help information found for command ${cmd_help}"
		fi
	    fi
	    exit
	    ;;
	--*)
	    # if the next argument is dashed, we just add $1 to our collection
	    # of dashed arguments. If $2 is NOT dashed, we assume it is a parameter
	    # to the --dashed option, and we grab it as well. Don't try and mix
	    # dashed and non-dashed, since we'll grab them!
	    case $2 in
		--*)
		    dashed="${dashed} $1"
		    ;;
		*)
		    # sneak a : in between, so we can split it later
		    dashed="${dashed} $1:$2"
		    shift
		    ;;
	    esac
	    ;;
	*://*)
	    non_dashed="${non_dashed} $1"
	    ;;

	*:*)
	    if [ -z "${no_exec_in_input}" ]; then
		# once we see something of the format <foo>:<var>, we are done processing,
		# since all other options are for the embedded command
		cmd=exec
		exec_cmd=$@
		shift $#
	    else
		non_dashed="${non_dashed} $1"
	    fi
	    ;;
        *)  non_dashed="${non_dashed} $1"
	    if [ "$1" = "store" ]; then
		# store takes a possible format that could be mistaken for the *:* of
		# the exec below. So we need to set a flag to inhibit it.
		no_exec_in_input=t
	    fi
            ;;
    esac
    shift
done

container_dir="/opt/container"

# returns 1 if we are container, 0 otherwise
function am_i_a_container()
{
    local virt_bin=$(which systemd-detect-virt)

    # if we can't run detection, just say we aren't a container
    if [ -z "${virt_bin}" ]; then
	return 0
    fi

    local virt=$(systemd-detect-virt)
    case $virt in
	lxc*)
	    return 1
	    ;;
	container*)
	    return 1
	    ;;
	docker*)
	    return 1
	    ;;
    esac

    return 0
}

# only dom0 has visibility to essential
if [ -d "/var/lib/cube/essential" ]; then
    we_are_dom0=t
fi
am_i_a_container
if [ $? -eq 1 ]; then
    we_are_a_container=t
fi

if [ -z "${we_are_dom0}" ] && [ -n "${we_are_a_container}" ]; then
    cube-cmd cube-ctl ${raw_command}
    exit $?
fi

# make an array from whatever was non-dashed
cmd_options_non_dashed=(${non_dashed})

if [ -z "${cmd}" ]; then
    # the first element is the command
    cmd=${cmd_options_non_dashed[0]}
fi

check_required()
{
    if [ ! -e "${1}" ]; then
	echo "[ERROR]: required command ${1} not found, exiting"
	exit 1
    fi
}

check_if_present()
{
    if [ -e "${1}" ]; then
	return 0
    fi
    return 1
}

# outputs:
#   machines: raw output from machinectl
#   oci: raw output from runc
#
#   cubes: list of running cubes
#   open_containers: list of running open containers
build_container_lists()
{
    # there are cubes, find them via machinectl
    machines="$(cube-cmd machinectl)"
    # drop the machinectl count of machines
    machines=$(echo "${machines}" | sed '/machines listed/d')

    # these are globally used, and must be reset whenever the
    # container list is rebuilto
    open_containers=
    cubes=
    open_container_available=
    cubes_available=

    # and then there are open containers
    graft_binaries_to_essential runc
    if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	runc_essential="/var/lib/cube/essential/sbin/runc"
    else
	echo "ERROR: unable to execute runc on essential"
	exit 1
    fi
    oci=$(cube-cmd ${runc_essential} list)

    # and then there are all the possible containers, which are
    # all found in /opt/container/<name>. We can tell the difference
    # between oci and cubes by the config files in the directory
    containers_available=$(ls /opt/container/)
    for c in ${containers_available}; do
	if [ -e "/opt/container/${c}/pflask.cmd" ]; then
	    cubes_available="${cubes_available} ${c}"
	elif [ -e "/opt/container/${c}/config.json" ]; then
	    open_container_available="${open_container_available} ${c}"
	fi
	## TODO: test for some other oci artifacts.
    done

    # take a copy of the "available" variables, since if a container is
    # detected as running below it is removed from the 'available', since
    # 'available' means "available to be started"
    cubes_all="${cubes_available}"
    open_container_all="${open_container_available}"

    # short form output
    OLDIFS=$IFS
IFS="
"
    for l in ${machines} ${oci}; do

	# collapse all whitespace to a single space for the cut lines below
	l=$(echo ${l} | sed -e "s/[[:space:]]\+/ /g")

	case ${l} in
	    MACHINE*)
		# do nothing, it's a header from machinectl
		ctype="cube"
		;;
	    ID*)
		# do nothing, it's a header from runc
		ctype="oci"
		;;
	    *)
		cname=$(echo "${l}" | cut -f 1 -d' ')
		cstate=$(echo "${l}" | cut -f 3 -d' ')
		if [ "${ctype}" == "cube" ]; then
		    cubes="${cubes} ${cname}"
		fi
		if [ "${ctype}" == "oci" ]; then
		    open_containers="${open_containers} ${cname}"
		fi

		case $cstate in
		    stopped)
			if [ "${ctype}" == "oci" ]; then
			    open_container_stopped="${open_container_stopped} ${cname}"
			    open_container_available=$(echo ${open_container_available} | sed "s/${cname}//")
			fi
			;;
		    *)
			# if we don't recognize the state .. assume it is running
			if [ "${ctype}" == "oci" ]; then
			    open_container_running="${open_container_running} ${cname}"
			    open_container_available=$(echo ${open_container_available} | sed "s/${cname}//")
			fi
			if [ "${ctype}" == "cube" ]; then
			    cubes_running="${cubes_running} ${cname}"
			    cubes_available=$(echo ${cubes_available} | sed "s/${cname}//")
			fi
			;;
		esac
		;;
	esac
    done
    IFS=$OLDIFS
}

# Check if the passed string matches any known container names
# return false (1) if unknown, true (0) if known
# additionally sets the global ${containers}
check_is_known_container()
{
    local container_name=$1
    container_is_a_oci=""
    container_is_a_cube=""

    # if we are not in a container .. then there's no need to check anything
    # just return that this is not a known container
    if [ -z "${we_are_a_container}" ]; then
	return 1
    fi

    build_container_lists

    if [ -n "${we_are_dom0}" ]; then
	echo ${cubes} | grep -w -q ${container_name}
	if [ $? -eq 0 ]; then
	    container_is_a_cube=t
	fi
	# grep -w can fail us, since containers with '.' in their name will be
	# mistaken as already in the system. So we replace the start of the string, the end
	# and any spaces with '#' and then use that as our delimeter
	containers=$(echo ${open_containers} ${open_container_available} | sed 's/^/#/' | sed 's/$/#/' | sed 's/ /#/g')
	echo ${containers} | grep -q "#${container_name}#"
	if [ $? -eq 0 ]; then
	    container_is_a_oci=t
	fi
	if [ -z "${container_is_a_cube}" ] && [ -z "${container_is_a_oci}" ]; then
	    return 1
	fi
    else
	return 1
    fi

    return 0
}

# return the names of containers, found by an attribute
container_by_attribute() {
    local attribute=$1
    local matches=""

    build_container_lists
    for c in ${open_containers} ${cubes}; do
	a=$(cube-cfg -n ${c} attribute)
	if [ "${a}" = "${attribute}" ]; then
	    matches="${matches} ${c}"
	fi
    done

    # strip leading and trailing whitespace
    echo ${matches} | sed 's/^[ \t]*//;s/[ \t]*$//'
}

graft_binaries_to_essential()
{
    local binaries=$@

    if [ -z "${we_are_a_container}" ]; then
	return
    fi
    if [ -z "${we_are_dom0}" ]; then
	return
    fi

    if [ ! -d "/var/lib/cube/essential/sbin/" ]; then
	mkdir -p "/var/lib/cube/essential/sbin/"
    fi

    for b in ${binaries}; do
	if [ ! -e "/var/lib/cube/essential/sbin/${b}" ]; then
	    bin="${b}"
	    if [ ! -f "${bin}" ]; then
		bin=$(which ${b})
	    fi
	    if [ ! -f "${bin}" ]; then
		echo "ERROR: binary ${b} not found"
		continue
	    fi
	    # Copy it in archive mode to include extend attributes used for IMA
	    cp -af ${bin} /var/lib/cube/essential/sbin/
	fi
    done
}

# arg1: path to the container rootfs
tweak_container_fstab()
{
    local rootfs=$1

    # Remove the systemd's costly remount of the root partition from /etc/fstab,
    # and also remove API filesystems mounting from it, as systemd will mount them itself.
    if [ -e ${rootfs}/etc/fstab ] ; then
	sed -i '\/dev\/root/d' ${rootfs}/etc/fstab
	sed -i '/^proc/d' ${rootfs}/etc/fstab
	sed -i '/^devpts/d' ${rootfs}/etc/fstab
	sed -i '/^tmpfs/d' ${rootfs}/etc/fstab
	sed -i '/^usbdevfs/d' ${rootfs}/etc/fstab
    fi
}

#
# arg1: the container name
# arg2: the container storage directory (note: *not* the rootfs dir)
#
# We generate a base configuration, and then tweak it for the
# various container formats.
#
generate_lxc_config()
{
    local cn=$1
    local container_storage=$2

    cat << EOF >${container_storage}/${cn}/config
lxc.utsname = ${cn}
lxc.rootfs = ${container_storage}/${cn}/rootfs
lxc.autodev = 1
lxc.kmsg = 0
lxc.tty = ${tty_num}
lxc.pts = 0
lxc.mount = ${container_storage}/${cn}/fstab
lxc.network.type = veth
lxc.network.name = veth0
lxc.network.script.up = /etc/lxc/ovs-up
lxc.network.script.down = /etc/lxc/ovs-down
lxc.group = ${group}
lxc.start.auto = ${autostart}
overc.start.auto = ${peerstart}
EOF
    if [ ${cn} == "dom0" ]; then
	echo "lxc.uncontain = 1" >> ${container_storage}/${cn}/config
	# Domain 0 wants to drive X onto a real console
	echo "lxc.console = none" >>${container_storage}/${cn}/config
    fi

    if [ -n "${subuid}" ]; then
	# for unprivileged containers, we need to use the mixed structure to
	# isolate the control of the container itself from the upper layer.
	echo "lxc.mount.auto = cgroup:mixed proc:mixed sys:mixed" >>${container_storage}/${cn}/config
	# subuid/subgid configuration for unprivileged container
	echo "lxc.id_map = u 0 ${subuid} 65536" >>${container_storage}/${cn}/config
	echo "lxc.id_map = g 0 ${subuid} 65536" >>${container_storage}/${cn}/config
    else
	# privileged containers
	echo "lxc.mount.entry = devpts ${container_storage}/${cn}/rootfs/dev/pts devpts gid=5,mode=620 0 0" >>${container_storage}/${cn}/config
	echo "lxc.mount.entry = proc ${container_storage}/${cn}/rootfs/proc    proc defaults 0 0" >>${container_storage}/${cn}/config
	echo "lxc.mount.entry = sysfs ${container_storage}/${cn}/rootfs/sys     sysfs defaults 0 0" >>${container_storage}/${cn}/config
	echo "lxc.hook.autodev = ${container_storage}/${cn}/autodev" >>${container_storage}/${cn}/config
    fi

    if [ ${havettyconsole} == 1 ]; then
	echo "overc.screen-getty = 1" >>${container_storage}/${cn}/config
    fi
}

# arg1: services name, could be globs
# arg2: container name (optional)
service_disable()
{
    local services="$1"
    local cname="$2"
    local container_storage="$3"
    local slinks

    services="${services%.service}.service"
    local debug_msg="[INFO]: Can not find the service ${services} to disable"

    if [ -z "${cname}" ]; then
        # For essential
        slinks=$(find ${container_storage}/etc/systemd/ -name ${services} 2>/dev/null)
        debug_msg="${debug_msg} for essential."
    else
        # For containers
        slinks=$(find ${container_storage}/${cname}/rootfs/etc/systemd/ -name ${services} 2>/dev/null)
        debug_msg="${debug_msg} for ${cname}."
    fi

    if [ -z "${slinks}" ]; then
        debugmsg ${DEBUG_INFO} ${debug_msg}
        return 1
    fi

    rm -f ${slinks}
    return 0
}

# arg1: the container name
# arg2: the path to the container storage
tweak_container_devices()
{
    local container_name=$1
    local container_storage=$2

    local mgr=$(${SBINDIR}/cube-cfg -o ${container_storage}/${container_name} get cube.device.mgr)

    if [ "${mgr}" = "essential" ]; then
	# we have to disable systemd udevd if it is in the container
	if [ -e ${container_storage}/${container_name}/rootfs/etc/systemd/system ]; then
	    ln -sf /dev/null ${container_storage}/${container_name}/rootfs/etc/systemd/system/systemd-udevd.service
	    ln -sf /dev/null ${container_storage}/${container_name}/rootfs/etc/systemd/system/systemd-udevd-kernel.socket
	    ln -sf /dev/null ${container_storage}/${container_name}/rootfs/etc/systemd/system/systemd-udevd-control.socket
	fi
    else
	# we have to re-enable systemd udevd if it is in the container. By simply removing
	# the links to /dev/null (if they exist) we'll re-nable udevd
	if [ -e ${container_storage}/${container_name}/rootfs/etc/systemd/system ]; then
	    rm -f ${container_storage}/${container_name}/rootfs/etc/systemd/system/systemd-udevd.service
	    rm -f ${container_storage}/${container_name}/rootfs/etc/systemd/system/systemd-udevd-kernel.socket
	    rm -f ${container_storage}/${container_name}/rootfs/etc/systemd/system/systemd-udevd-control.socket
	fi
    fi

    # TODO: tty handling
    # # harttyconsole == 1 means the container gets the real device
    # if [ ${hardttyconsole} == 1  ]; then
    #	# If container /dev is mounted by tmpfs (when lxc.autodev=1) then
    #	# systemd fails to start dev-ttyXXXX.device service and this causes
    #	# serial-getty@ttyXXXX.service fails to start.  Workaround for now
    #	# is to remove the dependency to dev-%i.device service.
    #	if [ -e ${pathtocontainer}/rootfs/lib/systemd/system/serial-getty@.service ] ; then
    #		sed -i "s:After=dev-%i.device :After=:g" ${pathtocontainer}/rootfs/lib/systemd/system/serial-getty@.service
    #	fi

    #	# remove serial console in the metal in order to pass it to the container
    #	serialconsoles=$( ls etc/systemd/system/getty.target.wants/serial-getty* etc/systemd/system/getty.target.wants/screen-getty* 2> /dev/null)
    #	for k in ${serialconsoles}; do
    #		ln -s -f /dev/null ${k}
    #	done
    # else
    #	# Mask out the container service serial-getty@${ttyconsoledev}.service
    #	serialconsoles=$( ls ${pathtocontainer}/rootfs/etc/systemd/system/getty.target.wants/serial-getty* 2> /dev/null)
    #	for k in ${serialconsoles}; do
    #		ln -s -f /dev/null ${k}
    #	done
    # fi

    # VT handling
    local vts=$(${SBINDIR}/cube-cfg -o ${container_storage}/${container_name} device vt)
    if [ -n "${vts}" ]; then
	# Disable the autoTV (we don't want systemd to spawn services on VT switch)
	sed -i "s/#NAutoVTs=.*$/NAutoVTs=0/g" ${container_storage}/${container_name}/rootfs/etc/systemd/logind.conf
	sed -i "s/#ReserveVT=.*$/ReserveVT=0/g" ${container_storage}/${container_name}/rootfs/etc/systemd/logind.conf
	gettys=$( ls ${container_storage}/${container_name}/rootfs/etc/systemd/system/getty.target.wants/getty* )
	for k in ${gettys}; do
		ln -s -f /dev/null ${k}
	done

	for v in ${vts}; do
	    vty_num=$(echo $v | cut -f1 -d: | sed 's%/dev/tty%%')
	    ln -sf /lib/systemd/system/getty@.service ${container_storage}/${container_name}/rootfs/etc/systemd/system/getty.target.wants/getty@tty${vty_num}.service
	done

	sed -i "s%ConditionPathExists=/dev/tty0%#ConditionPathExists=/dev/tty0%g" ${container_storage}/${container_name}/rootfs/lib/systemd/system/getty@.service
    fi

}

# arg1: the container name
# arg2: the path to the container storage
# arg3: allocate terminal ('t' or 'f')
tweak_container_terminal()
{
    local container_name=$1
    local container_path=$2
    local alloc_terminal=$3

    # if the command is interactive, we need to ensure that a terminal is allocated
    # or it won't work / look like it is hung
    terminal_json=$(jq -r '.process.terminal' ${container_path}/${container_name}/config.json)
    if [ "${alloc_terminal}" = "t" ] && [ "${terminal_json}" = "false" ] ; then
	jq -r  '.process.terminal = true' ${container_path}/${container_name}/config.json > ${container_path}/${container_name}/config.json.terminal
	mv ${container_path}/${container_name}/config.json.terminal ${container_path}/${container_name}/config.json
    fi

    if [ "${alloc_terminal}" = "f" ] && [ "${terminal_json}" = "true" ] ; then
	jq -r  '.process.terminal = false' ${container_path}/${container_name}/config.json > ${container_path}/${container_name}/config.json.terminal
	mv ${container_path}/${container_name}/config.json.terminal ${container_path}/${container_name}/config.json
    fi
}

spinner()
{
    local pid=$!
    local delay=0.75
    local spinstr='|/-\'
    while [ "$(ps a | awk '{print $1}' | grep $pid)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

get_container_ips() {
    local container_name=$1

    dpid=$(cat ${container_dir}/${container_name}/.cube.pid)
    ip_ext=$(cube-cmd nsenter -t ${dpid} -n ip route get 8.8.8.8 | tr -s ' ' | cut -d' ' -f7)
    ip_int=$(cube-cmd nsenter -t ${dpid} -n ip route get 192.168.42.254 | tr -s ' ' | cut -d' ' -f5)

    if [ "${ip_ext}" == "${ip_int}" ]; then
	echo ${ip_ext}
    else
	echo "${ip_int},${ip_ext}"
    fi
}

get_container_type() {
    local container_name=$1

    if [ -e "${container_dir}/${container_name}/pflask.cmd" ]; then
	echo cube
    else
	echo oci
    fi
}

get_container_attributes() {
    local container_name=$1
    local attributes=$(cube-cfg -n ${container_name} attribute | sed 's/^ *$//')

    echo ${attributes}
}

#
# Command processing
#
# This is getting a bit large, and could be broken out into separate commands
# at some point, but for now, we leverage a common code base and set of 
# utility routines.
#
case "${cmd}" in
    add)
	if [ -z "${container_type}" ]; then
	    container_type="oci"
	fi
	# the first non dashed argument will be the container source
	container_source=${cmd_options_non_dashed[1]}

	if [ -z "${container_source}" ]; then
	    echo "[ERROR]: no container source provided"
	    echo ""
	    usage_add
	    exit 1
	fi

	for o in ${dashed}; do
	    case ${o} in
		-n*)
		    container_name=`echo $o | cut -d: -f2`
		    ;;
		*)
		    echo "Unknow parameter ..."
		    usage_add
		    exit 1
		    ;;
	    esac
	done

	# test to see if the container_source is a url!

	# extract the protocol
	proto="$(echo ${container_source} | grep :// | sed -e's,^\(.*://\).*,\1,g')"
	# remove the protocol
	url="$(echo ${container_source/$proto/})"
	# extract the user (if any)
	user="$(echo $url | grep @ | cut -d@ -f1)"
	# extract the host
	host="$(echo ${url/$user@/} | cut -d/ -f1)"
	# by request - try to extract the port
	port="$(echo $host | sed -e 's,^.*:,:,g' -e 's,.*:\([0-9]*\).*,\1,g' -e 's,[^0-9],,g')"
	# extract the path (if any)
	path="$(echo $url | grep / | cut -d/ -f2-)"

	if [ -n "${verbose}" ]; then
	    echo "url: $url"
	    echo "  proto: $proto"
	    echo "  user: $user"
	    echo "  host: $host"
	    echo "  port: $port"
	    echo "  path: $path"
	fi

	# if no name was provided, we just generate one from the source
	if [ -z "${container_name}" ]; then
	    filename=$(basename "$container_source")
	    extension="${filename##*.}"
	    filename="${filename%%.*}"
	    container_name="$(cubename ${filename})"
	fi

	if [ -n "${host}" ]; then
	    # see if there's a tag in the input. awk gets us the last : ->
	    # end of line, which could be a tag.  but if that tag has //
	    # in it, it is just the docker:// that started the source
	    tag="latest"
	    possible_tag=$(echo ${container_source} | awk -F':' '{print $NF}')
	    echo ${possible_tag} | grep -q '//'
	    if [ $? -ne 0 ]; then
		# no slashes found, that's a tag
		tag="${possible_tag}"
	    fi
	    container_source=$(echo ${container_source} | sed "s#:${tag}##")
	    host=$(echo ${host} | sed "s#:${tag}##")
	    path=$(echo ${path} | sed "s#:${tag}##" | sed "s#/#-#")
	fi

	if [ -z "${container_name}" ]; then
	    container_name="$host"
	    if [ -n "${path}" ]; then
		container_name="$host-$path"
	    fi
	fi

	if [ -z "${container_name}" ]; then
	    echo "[ERROR]: no container name could be determined from ${container_source}"
	    echo "         a name can be provided via -n <name>"
	    exit 1
	fi

	if check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} already exists, cannot add."
	    exit 1
	fi

	# unprivileged. create default subuid/subgids for root and pass the
	# command to cube-cmd for container settings
	if [ -n "${subuid}" ]; then
	    if [ -n "${we_are_a_container}" ]; then
		privilege_param="-u ${subuid}"
		cube-cmd cmd "touch /etc/subuid /etc/subgid"
		cube-cmd cmd "usermod --add-subuids ${subuid}-$(( subuid+65536 )) root"
		cube-cmd cmd "usermod --add-subgids ${subuid}-$(( subuid+65536 )) root"
	    else
		touch /etc/subuid /etc/subgid
		usermod --add-subuids ${subuid}-$(( subuid+65536 )) root
		usermod --add-subgids ${subuid}-$(( subuid+65536 )) root
	    fi
	fi

	# regardless of the container type, we unpack the container source
	if [ -z "${out_dir}" ]; then
	    out_dir="${container_dir}/"
	fi

	if [ -n "${track_containers}" ]; then
	    ${SBINDIR}/overc-ctl track ${container_name} -o ${out_dir}
	fi
	mkdir -p "${out_dir}/${container_name}/rootfs"
	case ${container_source} in
	    *.tar*)
		echo "[INFO] Installing container ${container_name} to ${out_dir}/${container_name}"
		echo "[INFO] Extracting rootfs....."
		tar --numeric-owner --warning=no-timestamp \
		    --xattrs --xattrs-include=security\\.ima \
		    -xf ${container_source} -C ${out_dir}/${container_name}/rootfs
		if [ $? != 0 ]; then
		    echo "[ERROR]: rootfs file extraction failed"
		    exit 1
		fi
		;;
            cube://*)
		# for now, cubes are in docker registries
                ;&
	    docker://*)
		# make an oci format copy from the registry
		container_source=$(echo ${container_source} | sed 's%cube://%docker://%')

		# # see if there's a tag in the input. awk gets us the last : ->
		# # end of line, which could be a tag.  but if that tag has //
		# # in it, it is just the docker:// that started the source
		# tag="latest"
		# possible_tag=$(echo ${container_source} | awk -F':' '{print $NF}')
		# echo ${possible_tag} | grep -q '//'
		# if [ $? -ne 0 ]; then
		#     # no slashes found, that's a tag
		#     tag="${possible_tag}"
		# fi
		#container_source=$(echo ${container_source} | sed "s#:${tag}##")

		# TODO: make the tls setting an option
		flags="--dest-tls-verify=false --src-tls-verify=false"
		if [ -n "${verbose}" ]; then
		    echo "skopeo copy ${flags} ${container_source}:${tag} oci:${out_dir}/${container_name}/docker:${tag}"
		fi

		skopeo copy ${flags} ${container_source}:${tag} oci:${out_dir}/${container_name}/docker:${tag} 2> /dev/null
		if [ $? -ne 0 ]; then
		    echo "[ERROR]: docker container ${container_source} not found, check input and try again"
		    exit 1
		fi
	
		oci-image-tool create --ref ${tag} ${out_dir}/${container_name}/docker ${out_dir}/${container_name}/oci-runtime
		if [ $? -ne 0 ]; then
		    echo "[ERROR]: error OCI runtime could not be created from ${container_source}"
		    exit 1
		fi

		if [ -f "${out_dir}/${container_name}/oci-runtime/config.json" ]; then
		    entry_point=$(jq -r '.process.args | .[]' ${out_dir}/${container_name}/oci-runtime/config.json)
		    envs=$(jq -r '.process.env' ${out_dir}/${container_name}/oci-runtime/config.json)
		    if [ "${envs}" != "null" ]; then
			envs=$(jq -r '.process.env | .[]' ${out_dir}/${container_name}/oci-runtime/config.json)
		    else
			envs=""
		    fi
		fi

		# recursive call!! This may mean we need an import tool front end, instead of doing this here
		cube-ctl add -n ${container_name} ${out_dir}/${container_name}/oci-runtime

OLDIFS=$IFS
IFS='
'
		if [ -n "${envs}" ]; then
		    for e in $envs; do
			cube-cfg -n ${container_name} set cube.env:${e}
		    done
		fi
IFS=$OLDIFS
		if [ -n "${entry_point}" ]; then
		    cube-cfg -n ${container_name} set app:${entry_point}
		    echo ${entry_point} | grep -q init
		    if [ $? -eq 0 ]; then
			cube-cfg -n ${container_name} set cube.console.mgr:screen-tty
		    else
			cube-cfg -n ${container_name} set cube.console.mgr:tty
		    fi
		    cube-cfg gen ${container_name}:oci
		fi

		rm -rf ${out_dir}/${container_name}/docker
		rm -rf ${out_dir}/${container_name}/oci-runtime

		exit 0
		;;
	    *)
		if [ -d ${container_source} ]; then
		    echo "[INFO] Adding ${container_source} to ${container_name}"

		    # could be further refined to pick up a config.json and do an
		    # oci maniplation, but for now, we just cp -ar
		    if [ -d ${container_source}/rootfs ]; then
			cp -ar ${container_source}/rootfs ${out_dir}/${container_name}
		    else
			cp -ar ${container_source}/* ${out_dir}/${container_name}/rootfs
		    fi
		else
		    echo "[ERROR]: unknown container source"
		    exit 1
		fi
		;;
	esac
	echo "[INFO] Succeeded"

	if [ -n "${subuid}" ]; then
	    if [ -n "${we_are_a_container}" ]; then
		cube-cmd cmd "chown -R ${subuid}:${subuid} ${out_dir}/${container_name}/rootfs"
	    else
		chown -R ${subuid}:${subuid} ${out_dir}/${container_name}/rootfs
	    fi
	fi

	# cube (pflask)
	if [ "${container_type}" = "cube" ]; then
	    echo "[INFO] Performing cube configuration ..."
	    (
		# make sure that /var/lib/cube/essential and local exist
		# in the essential directory structure

		# see if someone arranged for /var/lib/cube to be mounted into out_dir, if
		# not, we need to go directly at /var/lib/cube
		var_dir=""
		if [ -d "${out_dir}/var/lib/cube/" ]; then
		    var_dir="${out_dir}"
		fi
		mkdir -p ${var_dir}/var/lib/cube/essential
		mkdir -p ${var_dir}/var/lib/cube/local

		cd ${out_dir}/${container_name}

		app="/sbin/init"
		${SBINDIR}/cube-cfg set app:${app}

		${SBINDIR}/cube-cfg mount bind:/opt/container:/opt/container
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube:/var/lib/cube
		# cubes are priviledged. By default pflask will mount
		# /proc/sys as read-only. This means that things (like
		# docker) that need to modify sys parameters will fail. By
		# adding and extra mount of essential's /proc/sys to the
		# container /proc/sys, we'll end up with a r/w /proc/sys.
		${SBINDIR}/cube-cfg mount bind:/proc/sys:/proc/sys
		${SBINDIR}/cube-cfg gen ${container_name}:cube
	    )

	    tweak_container_fstab ${out_dir}/${container_name}/rootfs
	    tweak_container_devices ${container_name} ${out_dir}

	    if [ -n "${auto}" ]; then
		${SBINDIR}/cube-cfg -o ${out_dir}/${container_name} set autostart:${auto}
	    fi
	fi

	# OCI (runc)
	if [ "${container_type}" = "oci" ]; then
	    echo "[INFO] Performing OCI configuration ..."
	    (
		cd ${out_dir}/${container_name}
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube/all:/var/lib/cube/common
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube/${container_name}:/var/lib/cube/local

		# assume /sbin/init (for now). this can be changed later by more calls to cube-cfg
		# and a regen of the config
		#   TODO: inspect the container for /sbin/init and then trigger this. Otherwise,
		#         not. That will keep the systemd hooks optional.. actually better, we should
		#         just look for a config from the manifest and use it as the entry point
		app="/sbin/init"
		${SBINDIR}/cube-cfg set app:${app}

		${SBINDIR}/cube-cfg hook-script poststart:/usr/libexec/oci/hooks.d/oci-network up \$\(cat\)
		${SBINDIR}/cube-cfg hook-script poststart:/usr/libexec/oci/hooks.d/oci-device up \$\(cat\)
		${SBINDIR}/cube-cfg hook-script poststop:/usr/libexec/oci/hooks.d/oci-network down \$\(cat\)
		${SBINDIR}/cube-cfg hook-script poststop:/usr/libexec/oci/hooks.d/oci-device down \$\(cat\)

		# this will trigger the disabling of systemd udev services, and allow us to control
		# the devices visible to the container
		${SBINDIR}/cube-cfg set cube.device.mgr:essential

		# Setup console with the screen-getty service
		${SBINDIR}/cube-cfg set cube.console.mgr:tty
		# Optionally setup the pty-console for use inside the container
		${SBINDIR}/cube-cfg mount bind:/var/lib/cube/${container_name}/pty-console:/dev/pty-console


		# update the container manager
		graft_binaries_to_essential runc
		${SBINDIR}/cube-cfg set cube.container.mgr:/var/lib/cube/essential/sbin/runc

		${SBINDIR}/cube-cfg gen ${container_name}:oci

		# see if someone arranged for /var/lib/cube to be mounted into out_dir, if
		# not, we need to go directly at /var/lib/cube
		var_dir=""
		if [ -d "${out_dir}/var/lib/cube/" ]; then
		    var_dir="${out_dir}"
		fi

		# make the dirs in essential, but they will be bind mounted to the container
		mkdir -p ${var_dir}/var/lib/cube/all
		mkdir -p ${var_dir}/var/lib/cube/${container_name}
	    )

	    tweak_container_fstab ${out_dir}/${container_name}/rootfs
	    tweak_container_devices ${container_name} ${out_dir}

	    if [ -n "${auto}" ]; then
		${SBINDIR}/cube-cfg -o ${out_dir}/${container_name} set autostart:${auto}
	    fi
	fi

	# LXC (lxc)
	if [ "${container_type}" = "lxc" ]; then
	    echo "[INFO] Performing lxc configuration ..."
	    generate_lxc_config ${container_name} ${out_dir}
	fi
	;;
    rename|mv)
	orig_name=${cmd_options_non_dashed[1]}
	new_name=${cmd_options_non_dashed[2]}

	if [ -z "${orig_name}" ]; then
	    echo "[ERROR]: existing name not provided"
	    usage_mv
	    exit 1
	fi
	if [ -z "${new_name}" ]; then
	    echo "[ERROR]: new name not provided"
	    usage_mv
	    exit 1
	fi

	check_is_known_container ${orig_name}
	if [ $? -eq 1 ]; then
	    echo "[ERROR]: container ${orig_name} is unknown, cannot rename"
	    usage_mv
	    exit 1
	fi
	check_is_known_container ${new_name}
	if [ $? -eq 0 ]; then
	    echo "[ERROR]: container ${new_name} already exists"
	    usage_mv
	    exit 1
	fi

	echo "${open_container_all}" | grep -q ${orig_name}
	if [ $? -ne 0 ]; then
	    echo "[ERROR]: only 'oci' containers can be renamed"
	    usage_mv
	    exit 1
	fi

	np=$(container_by_attribute netprime)
	if [ "${np}" = "${orig_name}" ]; then
	    echo "[ERROR]: ${orig_name} is the netprime, it cannot be renamed. See the 'netprime' command"
	    usage_netprime
	    exit 1
	fi

	build_container_lists
	# TODO: could be a function to check for a running container
	rcontainers=$(echo ${open_container_running} | sed 's/^/#/' | sed 's/$/#/' | sed 's/ /#/g')
	echo ${rcontainers} | grep -q "#${orig_name}#"
	if [ $? -eq 0 ]; then
	    # the container is running, we must stop it
	    echo "[INFO]: container ${orig_name} is running, stopping ..."
	    ${0##*/} stop ${orig_name}
	    was_running=t
	fi

	mv /opt/container/${orig_name} /opt/container/${new_name}
	sed "s#${orig_name}#${new_name}#g" -i /opt/container/${new_name}/oci.cmd
	if [ ! -d /var/lib/cube/${orig_name} ]; then
	    echo "[WARNING]: container state directory /var/lib/cube/${orig_name} not found"
	else
	    mv /var/lib/cube/${orig_name} /var/lib/cube/${new_name}
	    # TODO: this could be a series of cube-cfg calls ..
	    sed "s#/var/lib/cube/${orig_name}#/var/lib/cube/${new_name}#g" -i /opt/container/${new_name}/.cube.mount.bind
	fi

	echo "[INFO]: regenerating container configuration for ${new_name}"
	c3-cfg gen ${new_name}:oci

	if [ -n "${was_running}" ]; then
	    echo "[INFO]: restarting ${orig_name} as ${new_name} ..."
	    ${0##*/} start ${orig_name}
	fi
	;;
    prep)
	if [ -z "${container_type}" ]; then
	    container_type="oci"
	fi

	if [ -z "${container_name}" ]; then
	    # the first non dashed argument will be the container name/source
	    container_name=${cmd_options_non_dashed[1]}
	    if [ -z "${container_name}" ]; then
		echo "[ERROR]: no container name provided"
		usage_prep
		exit 1
	    fi
	fi

	tweak_container_fstab ${out_dir}/${container_name}/rootfs
	tweak_container_devices ${container_name} ${out_dir}
	;;
    store)
	# stores (copies, pushes, clones ..) a container

	if [ -z "${container_type}" ]; then
	    container_type="oci"
	fi
	# the first non dashed argument will be the container name/source
	container_source=${cmd_options_non_dashed[1]}
	# and the second is the dest
	container_dest=${cmd_options_non_dashed[2]}

	# The test below covers the following use case:
	#
	#   c3 store -n <name> <dest>
	#
	# Since the dest gets pulled in as the source, and the
	# source is really the container name. We shuffle things around
	# to get the right source and dest.
	if [ -z "${container_dest}" ]; then
	    if [ -n "${container_name}" ]; then
		container_dest=${container_source}
		container_source=${container_name}
	    fi
	fi
	if [ -z "${container_source}" ]; then
	    echo "[ERROR]: no container source provided"
	    usage_store
	    exit 1
	fi

	if [ -z "${container_name}" ]; then
	    container_name="${container_source}"
	fi

	# test to see if the container_source is a url!

	# extract the protocol
	src_proto="$(echo ${container_source} | grep :// | sed -e's,^\(.*://\).*,\1,g')"
	# remove the protocol
	src_url="$(echo ${container_source/$proto/})"
	# extract the user (if any)
	src_user="$(echo $url | grep @ | cut -d@ -f1)"
	# extract the host
	src_host="$(echo ${url/$user@/} | cut -d/ -f1)"
	# by request - try to extract the port
	src_port="$(echo $host | sed -e 's,^.*:,:,g' -e 's,.*:\([0-9]*\).*,\1,g' -e 's,[^0-9],,g')"
	# extract the path (if any)
	src_path="$(echo $url | grep / | cut -d/ -f2-)"

	src_tag="latest"
	echo ${container_source} | grep -q :
	if [ $? -eq 0 ]; then
	    possible_src_tag=$(echo ${container_source} | awk -F':' '{print $NF}')
	    echo ${possible_src_tag} | grep -q '//'
	    if [ $? -ne 0 ]; then
		# no slashes found, that's a tag
	        src_tag="${possible_src_tag}"
	    fi
	fi
	container_source=$(echo ${container_source} | sed "s#:${src_tag}##")
	container_name=$(echo ${container_name} | sed "s#:${src_tag}##")

	# extract the protocol
	dest_proto="$(echo ${container_dest} | grep :// | sed -e's,^\(.*://\).*,\1,g')"
	# remove the protocol
	dest_url="$(echo ${container_dest/$proto/})"
	# extract the user (if any)
	dest_user="$(echo $url | grep @ | cut -d@ -f1)"
	# extract the host
	dest_host="$(echo ${url/$user@/} | cut -d/ -f1)"
	# by request - try to extract the port
	dest_port="$(echo $host | sed -e 's,^.*:,:,g' -e 's,.*:\([0-9]*\).*,\1,g' -e 's,[^0-9],,g')"
	# extract the path (if any)
	dest_path="$(echo $url | grep / | cut -d/ -f2-)"

	# see if there's a tag in the input. awk gets us the last : ->
	# end of line, which could be a tag.  but if that tag has //
	# in it, it is just the docker:// that started the source
	dest_tag="latest"
	possible_dest_tag=$(echo ${container_dest} | awk -F':' '{print $NF}')
	echo ${possible_dest_tag} | grep -q '//'
	if [ $? -ne 0 ]; then
	    # no slashes found, that's a tag
	    dest_tag="${possible_dest_tag}"
	fi

	if [ -z "${src_proto}" ]; then
	    # we are working with a local container, so validate the name
	    check_is_known_container ${container_name}
	    if [ $? -eq 1 ]; then
		echo "[ERROR] Container ${container_name} is unknown, cannot store"
		exit 1
	    fi
	fi

	if [ -z "${dest_proto}" ]; then
	    check_is_known_container ${container_dest}
	    if [ $? -eq 0 ]; then
		echo "[ERROR] Container ${container_dest} already exists, cannot store"
		echo "        Use --force to overwrite existing container"
		# TODO: implement --force :D
		exit 1
	    fi
	fi

	# We support: container -> registry
	#             container -> container
	#             registry  -> registry
	#
	# NOTE: registry -> local is "add"
	#
	# NOTE: registries can be local or remote
	#

	# for now, we convert cube:// to docker:// (since we are not writing our
	# own registry protocol)
	container_source=$(echo ${container_source} | sed 's%cube://%docker://%')
	container_dest=$(echo ${container_dest} | sed 's%cube://%docker://%')

	if [ -n "${src_proto}" ] && [ -n "${dest_proto}" ]; then
	    echo "[INFO]: registry -> registry storage"

	    # TODO: make the tls setting an option
	    flags="--dest-tls-verify=false --src-tls-verify=false"
	    skopeo copy ${flags} ${container_source} ${container_dest}
	elif [ -n "${src_proto}" ] && [ -z "${dest_proto}" ]; then
	    echo "[INFO]: registry -> local storage is not support, use cube-ctl add"
	    exit 1
	elif [ -z "${src_proto}" ] && [ -n "${dest_proto}" ]; then
	    echo "[INFO]: local -> registry storage"

	    container_source="/opt/container/${container_source}"
	    if [ ! -d "${container_source}" ]; then
		echo "[ERROR] container source ${container_source} not found"
		exit 1
	    fi

	    # we have to make sure that the container is a valid OCI container, or
	    # we won't be able to copy it to the registry.

	    if [ ! -e "${container_source}/oci-layout" ]; then
		# the container is not in OCI format, we'll need to convert it

		echo -n "[INFO]: creating OCI manifest and blobs ... "

		# We create an empty oci container structure, and then copy it into
		# the original container. We could also copy the original container's
		# rootfs into the oci container, but that means moving Gigs of data
		# .. so we avoid it this way.
		umoci init --layout ${container_source}-oci
		umoci new --image ${container_source}-oci
		umoci unpack --image ${container_source}-oci ${container_source}-oci
		rm -f ${container_source}-oci/config.json
		cp -r ${container_source}-oci/* ${container_source}/
		rm -rf ${container_source}-oci
	    fi

	    # This can be expensive, but really only on the first run. consider detecting
	    # that situation and dumping a warning. Or we make the refresh an option Or
	    # we detect a timestamp and only do it if changed. But for now, we play it safe
	    # and always refresh.
	    umoci repack --refresh-bundle --image ${container_source} ${container_source} &
	    spinner
	    echo ""

	    umoci tag --image ${container_source} ${src_tag}

	    # Note: this could (and probably should) be done with cube.* values
	    #       rather than the json. But the json will always be in sync with
	    #       them .. so we go this way for now.
	    if [ -f "${container_source}/config.json" ]; then
		entry_point=$(jq -r '.process.args | .[]' ${container_source}/config.json)
		umoci config --config.entrypoint="${entry_point}" --image ${container_source}

		envs=$(jq -r '.process.env' ${container_source}/config.json)
		if [ "${envs}" != "null" ]; then
		    envs=$(jq -r '.process.env | .[]' ${container_source}/config.json)
		else
		    envs=""
		fi
OLDIFS=$IFS
IFS='
'
		if [ -n "${envs}" ]; then
		    for e in $envs; do
			umoci config --config.env="${e}" --image ${container_source}
		    done
		fi
IFS=$OLDIFS
	    fi

	    if [ -f "${container_source}/index.json" ]; then
		# placeholder for any manipulations we might want to do
		true
	    else
cat > ${container_source}/index.json <<EOF
		 {
		    "schemaVersion": 2,
		    "manifests": [
		      {
		        "mediaType": $(jq .mediaType ${container_source}/refs/${src_tag}),
		        "digest": $(jq .digest ${container_source}/refs/${src_tag}),
		        "size": $(jq .size ${container_source}/refs/${src_tag}),
		        "annotations": {
			    "org.opencontainers.image.ref.name": "${src_tag}"
		        },
		        "platform": {
			    "architecture": "amd64",
			    "os": "linux"
		        }
		      }
		    ]
		 }
EOF
	    fi

	    # TODO: make the tls setting an option
	    flags="--dest-tls-verify=false --src-tls-verify=false"

	    auth_string=$(cube-cfg auth docker | sed 's/\"//g' | sed 's/=$//')
	    if [ -n "${auth_string}" ]; then
		auth_parms="--dest-creds $(echo ${auth_string} | base64 -d)"
	    fi
	    echo "[INFO]: storing container ${container_source}"
	    if [ -n "${verbose}" ]; then
		skopeo_flags="--debug"
		echo "[INFO]: skopeo ${skopeo_flags} copy ${auth_parms} ${flags} oci:${container_source}:${src_tag} ${container_dest}"
	    fi
	    skopeo ${skopeo_flags} copy ${auth_parms} ${flags} oci:${container_source}:${src_tag} ${container_dest}
	elif [ -z "${src_proto}" ] && [ -z "${dest_proto}" ]; then
	    echo "[INFO]: local -> local storage"

	    container_source="/opt/container/${container_source}"
	    container_dest="/opt/container/${container_dest}"
	    if [ ! -d "${container_source}" ]; then
		echo "[ERROR] container source ${container_source} not found"
		exit 1
	    fi
	    if [ -d "${container_dest}" ]; then
		echo "[ERROR] container dest ${container_dest} already exists"
		exit 1
	    fi

	    cp -ar "${container_source}" "${container_dest}"
	fi
	;;
    stack)
	container_name=${cmd_options_non_dashed[1]}
	if [ -e ${container_dir}/${container_name}/cube.network.stack ]; then
	    if [ -n "${verbose}" ]; then
		echo "[INFO]: network stack detected, excuting commands"
	    fi
	    (
		cd ${container_dir}/${container_name}

		# we need to resolve an variable references. Currently this
		# is IPS and devices
		vars=$(cat cube.network.stack | awk -F"[{}]" '{print $2}' | sort | uniq)
		spid=$(cat .cube.pid)

		for v in $vars; do
		    case $v in
			*device*)
			    netdevs=$(cat .cube.device.network)
			    for n in ${netdevs}; do
				echo ${n} | grep -q veth
				if [ $? -ne 0 ]; then
				    # we have a real device. Last one wins.
				    device=$(echo ${n} | cut -f1 -d:)
				fi
			    done
			    ;;
			*_ip*)
			    cname=$(echo $v | sed -r 's/(.+)_.*/\1/')
			    # this doesn't actually go out on the wire, but it is the best
			    # way to get the IP of the interface in the container. If we need
			    # something besides the external route for the IP, this can be
			    # tweaked.
			    dpid=$(cat ${container_dir}/${cname}/.cube.pid)
			    ip=$(cube-cmd nsenter -t ${dpid} -n ip route get 8.8.8.8 | tr -s ' ' | cut -d' ' -f7)
			    eval ${cname}_ip=${ip}
			    ;;
		    esac
		done

		# read the commands, resolve variables and execute them in the proper
		# namespace
		while read -u 10 cmd; do
		    # With the variable creation above, these will echo without any unknown
		    # variables .. if there are remaining vars, it is an error.
		    echo ${cmd} | grep -q iptables
		    if [ $? -eq 0 ]; then
			cmd_check=$(echo ${cmd} | sed 's/iptables -A/iptables -C/')
			eval cube-cmd nsenter -t ${spid} -n --preserve-credentials "$cmd_check" 2> /dev/null
		    else
			# just so $? can run the command without a check :D
			false
		    fi
		    if [ $? -ne 0 ]; then
			if [ -n "${verbose}" ]; then
			    echo -n "INFO:"
			    eval echo cube-cmd nsenter -t ${spid} -n --preserve-credentials "$cmd"
			fi
			eval cube-cmd nsenter -t ${spid} -n --preserve-credentials "$cmd"
		    fi
		done 10<cube.network.stack
	    )
	fi
	;;
    del|delete|remove)
	graft_binaries_to_essential runc
	if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	    runc_essential="/var/lib/cube/essential/sbin/runc"
	else
	    echo "ERROR: unable to execute runc on essential"
	    exit 1
	fi

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if [ -z "${out_dir}" ]; then
	    out_dir="${container_dir}/"
	fi

	if ! check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} not found, cannot delete."
	    echo -n "Valid containers are: "
	    echo ${cubes} ${open_containers} ${open_container_available}
	    usage_del
	    exit 1
	fi

	if [ -n "${container_is_a_cube}" ]; then
	    # nothing to do at the moment
	    echo "[INFO]: not removing, container is a cube, only 'oci' containers can be removed"
	    true
	fi
	if [ -n "${container_is_a_oci}" ]; then
	    echo ${open_container_running} | grep -q ${container_name}
	    if [ $? -ne 0 ]; then
		echo "[INFO] deleting container ${container_name}"
		cube-cmd ${runc_essential} delete ${container_name} 2> /dev/null
		if [ -n "${track_containers}" ]; then
		    ${SBINDIR}/overc-ctl untrack ${container_name} -f -o ${out_dir}
		fi
		cube-cfg set overc/$(cube-cfg id)/oci/${container_name}/:
	    else
		echo "[INFO] container ${container_name} is running, it must be stopped before deleting"
	    fi
	fi
	;;
    start)
	# the second non dashed argument will be the container name
	container_names=${cmd_options_non_dashed[1]}
	if [ -z "${container_names}" ] && [ -z "${auto}" ]; then
	    usage_start
	    exit 1
	fi

	# if single_launch is set, then we don't use dtach, but instead let the
	# container go directly at the tty
	single_launch=t

	# The auto is the container tags that we should locate. If found, add them
	# to the container list
	if [ -n "${auto}" ]; then
	    echo "[INFO] auto starting containers ..."
	    for c in $(ls "${container_dir}/"); do
		if [ -d "${container_dir}/${c}" ]; then
		    if [ -e "${container_dir}/${c}/autostart" ]; then
			grep -q ${auto} "${container_dir}/${c}/autostart"
			if [ $? -eq 0 ]; then
			    container_names="${container_names} $(basename ${c})"
			fi
		    fi
		fi
	    done
	fi

	for container in ${container_names}; do
	    if [ -n "${single_launch}" ]; then
		if [ -e "${container_dir}/${container}/pflask.cmd" ]; then
		    ${container_dir}/${container}/pflask.cmd
		    cube-cfg set overc/$machine/cube/${container}/:active
		elif [ -e "${container_dir}/${container}/config.json" ]; then
		    (
			if [ -n "${we_are_dom0}" ]; then
			    # This escapes our namespace and launches the containers in our parents (essential)
			    # namespace. But in that structure, runc may not be available so we copy it first and
			    # then use it directly.
			    build_container_lists

			    oc=$(echo ${open_container_running} | sed 's/^/#/' | sed 's/$/#/' | sed 's/ /#/g')
			    echo "${oc}" | grep -q "#${container}#"
			    if [ $? -ne 0 ]; then
				if [ -n "${foreground}" ]; then
				    oci_args="foreground"
				    cube-cfg -r -n ${container} set cube.console.mgr:
				fi

				console_mgr=$(cube-cfg -r -n ${container} cube.console.mgr:)
				tty_flag="f"
				if [ "${console_mgr}" = "tty" ] || [ "${console_mgr}" = "screen-tty" ]; then
				    tty_flag="t"
				fi

				# re-run the tweaks (in case a config changed)
				tweak_container_terminal ${container} ${container_dir} ${tty_flag}
				tweak_container_fstab ${container_dir}/${container}/rootfs
				tweak_container_devices ${container} ${container_dir}

				# this will regenerate the config using any .runonce values, otherwise
				# it will do nothing.
				cube-cfg -r gen ${container}:oci

				# oci.cmd is created dynamically at install time without IMA signature.
				# So we can't run it directly, use "/bin/bash oci.cmd" to work around IMA checking
				nsenter -P -t 1 -p -n -u -m -C /bin/bash /opt/container/${container}/oci.cmd ${oci_args}
				# TODO: move this cube-cfg call into a pre-start hook, same with the
				#       delete of the key
				machine=$(cube-cfg id)
				cube-cfg set overc/$machine/oci/${container}/status:active

				# remove any runonce settings
				cube-cfg -r -n ${container} clean
				# a return code of one means that settings were cleared, so we regen
				if [ $? -eq 1 ]; then
				    cube-cfg gen ${container}:oci
				fi
			    else
				echo "container ${container} is already running ..."
			    fi
			else
			    # TODO: use cube-cmd to talk to a remote container manager
			    true
			fi
		    )
		fi
	    fi
	done

	# once everything has started, look for stacked network commands
	for container in ${container_names}; do
	    cube-ctl stack ${container}
	done
	;;
    status|list)
	build_container_lists

	if [ -n "${verbose}" ]; then
	    machines=$(echo "${machines}" | sed 's/^/   /')
	    oci=$(echo "${oci}" | sed 's/^/   /')
	    echo "cubes:"
	    echo ""
	    echo "${machines}"
	    echo ""
	    echo "open containers:"
	    echo ""
	    echo "${oci}"
	else
	    output=$(mktemp)
	    echo "name type status attributes addresses" > ${output}
	    echo "---- ---- ------ ---------- ---------" >> ${output}
	    for l in ${open_container_running}; do
		attributes=$(get_container_attributes ${l})
		if [ -z "${attributes}" ]; then
		    attributes="--"
		fi
		ip=$(get_container_ips ${l})
		echo "${l} oci running ${attributes} ${ip}" >> ${output}
	    done
	    for l in ${open_container_stopped}; do
		attributes=$(get_container_attributes ${l})
		if [ -z "${attributes}" ]; then
		    attributes="--"
		fi
		echo "${l} oci stopped ${attributes} --" >> ${output}
	    done
	    for l in ${cubes_running}; do
		ip=$(get_container_ips ${l})
		attributes=$(get_container_attributes ${l})
		if [ -z "${attributes}" ]; then
		    attributes="--"
		fi
		echo "${l} cube running ${attributes} ${ip}" >> ${output}
	    done
	    for l in ${open_container_available}; do
		attributes=$(get_container_attributes ${l})
		if [ -z "${attributes}" ]; then
		    attributes="--"
		fi
		echo "${l} oci available ${attributes} --" >> ${output}
	    done
	    for l in ${cubes_available}; do
		attributes=$(get_container_attributes ${l})
		if [ -z "${attributes}" ]; then
		    attributes="--"
		fi
		echo "${l} cube available ${attributes} --" >> ${output}
	    done
	    cat ${output} | column -t
	    rm ${output}
IFS=$OLDIFS
	fi
	;;
    info|show)
	build_container_lists

	graft_binaries_to_essential runc
	if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	    runc_essential="/var/lib/cube/essential/sbin/runc"
	else
	    echo "ERROR: unable to execute runc on essential"
	    exit 1
	fi

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if [ -n "${container_name}" ]; then
	    echo ${cubes} | grep -q ${container_name}
	    if [ $? -eq 0 ]; then
		container_is_a_cube=t
	    fi
	    echo ${open_containers} ${open_container_available} | grep -q ${container_name}
	    if [ $? -eq 0 ]; then
		container_is_a_oci=t
	    fi
	    if [ -z "${container_is_a_cube}" ] && [ -z "${container_is_a_oci}" ]; then
		echo "ERROR: container ${container_name} is not known"
		exit 1
	    fi

	    if [ -n "${container_is_a_cube}" ]; then
		if [ -n "${verbose}" ]; then
		    cube-cmd machinectl status ${container_name}
		else
		    cube-cmd machinectl show ${container_name}
		fi
	    fi
	    if [ -n "${container_is_a_oci}" ]; then
		echo "state:"
		echo "------"
		echo ${open_containers} | grep -q ${container_name}
		if [ $? -eq 0 ]; then
		    cube-cmd ${runc_essential} state ${container_name}
		else
		    echo "not running (or created)"
		fi
		echo ""
		echo ""
		cube-cfg -n ${container_name} show
	    fi
	else
	    echo "[ERROR]: provide a container name to see detailed information"
	    usage_show
	    exit 1
	fi
	;;
    netprime)
	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if [ -z "${container_name}" ]; then
	    # if no container name was passed, we just output the netprime
	    np=$(container_by_attribute netprime)
	    if [ -n "${np}" ]; then
		echo ${np}
	    fi
	    exit 0
	fi

	if ! check_is_known_container ${container_name}; then
	    echo "[ERROR] Container ${container_name} not found, cannot set as netprime."
	    echo -n "Valid containers are: "
	    echo ${cubes} ${open_containers}
	    exit 1
	fi

	attributes=$(${SBINDIR}/cube-cfg -n ${container_name} attribute)
	echo ${attributes} | grep -q netprime
	if [ $? -eq 0 ]; then
	    echo "[INFO]: container \"${container_name}\" is already the netprime"
	    exit 0
	fi

	if [ -z "${out_dir}" ]; then
	    out_dir="${container_dir}"
	fi

	# TODO: this could be an etcd lookup, not this ...
        containers_available=$(ls ${out_dir})
	for c in ${containers_available}; do
	    attributes=$(${SBINDIR}/cube-cfg -n ${c} attribute)
	    echo ${attributes} | grep -q netprime
	    if [ $? -eq 0 ]; then
		network_prime_old=${c}
	    fi
	done
	network_prime=${container_name}

	# step 1: stop the old network prime (if it exists)
	if [ -n "${network_prime_old}" ] && [ "${network_prime_old}" != "dom0" ]; then
	    (
		if [ -n "${verbose}" ]; then
		    echo "[INFO]: stopping current netprime (${network_prime_old})"
		fi
		cd ${out_dir}/${network_prime_old}
		# TODO: how to detect if we are the installer and not run this ?
		${SBINDIR}/cube-ctl stop ${network_prime_old}
	    )
	fi

	# step 2: configure the new network prime
	(
	    if [ -n "${verbose}" ]; then
		echo "[INFO]: configuring new netprime (${network_prime})"
	    fi
	    cd ${out_dir}/${network_prime}

	    ${SBINDIR}/cube-cfg set cube.network.type:static
	    ${SBINDIR}/cube-cfg --prepend set cube.network.ip:192.168.42.1/24

	    devs=$(${SBINDIR}/cube-cfg -o ${out_dir}/${network_prime_old} device network)
	    for d in ${devs}; do
		echo "${d}" | grep -q veth
		# add any h/w devices that will be passed through, leave the veth
		if [ $? -ne 0 ]; then
		    ${SBINDIR}/cube-cfg device network:$d
		fi
	    done

	    ${SBINDIR}/cube-cfg attribute +netprime

	    # ensure that etcd (on dom0) is accessible
	    ${SBINDIR}/cube-cfg link ${network_prime}:2379 dom0:2379

	    type=$(get_container_type ${network_prime})
	    if [ "${type}" == "oci" ]; then
		${SBINDIR}/cube-cfg hook-script poststart:/usr/libexec/cube/hooks.d/cube-netconfig netprime \$\(cat\)
		service_disable systemd-resolved.service ${network_prime} ${out_dir}
		# Q: do we make a DNS manager ? and then execute on it during the container start via the hooks ?
	    else
		${SBINDIR}/cube-cfg hook-script poststart:/usr/libexec/cube/hooks.d/cube-netconfig netprime /opt/container/${network_prime}
		service_disable systemd-resolved.service ${network_prime} ${out_dir}
	    fi

	    ${SBINDIR}/cube-cfg gen ${network_prime}:$type
	)

	# step 3: reconfigure the old network prime (if it exists)
	# TODO: there could be an option to skip this (so you could switch back without needing
	#       to rerun the netprime command
	if [ -n "${network_prime_old}" ]; then
	    (
		if [ -n "${verbose}" ]; then
		    echo "[INFO]: reconfiging previous netprime"
		fi
		# TODO: this won't work if called from the installer, the dir for containers
		#       needs to vary and we can't stop the container
		cd ${out_dir}/${network_prime_old}
		${SBINDIR}/cube-cfg attribute -netprime
		${SBINDIR}/cube-cfg set cube.network.type:dynamic
		${SBINDIR}/cube-cfg set -cube.network.ip:192.168.42.1/24

		devs=$(${SBINDIR}/cube-cfg -o ${out_dir}/${network_prime_old} device network)
		for d in ${devs}; do
		    echo "${d}" | grep -q veth
		    # drop any h/w devices that were passed through, leave the veth
		    if [ $? -ne 0 ]; then
			${SBINDIR}/cube-cfg device -network:$d
		    fi
		done

		# remove the old hook and etcd port forward
		${SBINDIR}/cube-cfg hook-script -poststart:/usr/libexec/cube/hooks.d/cube-netconfig netprime \$\(cat\)
		${SBINDIR}/cube-cfg link -${network_prime_old}:2379 dom0:2379

		type=$(get_container_type ${network_prime_old})
		${SBINDIR}/cube-cfg gen ${network_prime_old}:$type
	    )
	fi
	;;
    stop|pause)
	graft_binaries_to_essential runc
	if [ -f "/var/lib/cube/essential/sbin/runc" ]; then
	    runc_essential="/var/lib/cube/essential/sbin/runc"
	else
	    echo "[ERROR]: unable to execute runc on essential"
	    exit 1
	fi

	# the second non dashed argument will be the container name
	container_name=${cmd_options_non_dashed[1]}

	if [ -z "${container_name}" ]; then
	    echo "[ERROR]: no container name provided"
	    usage_stop
	    exit 1
	fi

	if ! check_is_known_container ${container_name}; then
	    echo "[ERROR]: container ${container_name} not found, cannot stop."
	    echo -n "Valid containers are: "
	    echo ${cubes} ${open_containers}
	    exit 1
	fi

	if [ -n "${container_is_a_cube}" ]; then
	    cube-cmd machinectl stop ${container_name}
	fi
	if [ -n "${container_is_a_oci}" ]; then
	    build_container_lists
	    echo ${open_container_running} | grep -q ${container_name}
	    if [ $? -eq 0 ]; then
		echo "[INFO]: stopping container ${container_name}"
		cube-cmd ${runc_essential} kill ${container_name} KILL
		if [ "${cmd}" == "stop" ]; then
		    cube-cmd ${runc_essential} delete -f ${container_name}
		fi
		machine=$(cube-cfg id)
		cube-cfg set overc/$machine/oci/${container_name}/status:inactive
	    else
		if [ "${cmd}" == "stop" ]; then
		    cube-cmd ${runc_essential} delete -f ${container_name}
		fi
	    fi
	fi
	;;
    exec)
	if [ -z "${we_are_a_container}" ]; then
	    echo "ERROR: host detected, cube-ctl only works in a monitored container."
	    echo "       Commands must be directly invoked in essential, control functions"
	    echo "       via the control domain."
	    exit 1
	fi

	# this is execute: <target>:<command>

	# remove the : separator
	non_dashed_no_colon=`echo ${exec_cmd[@]} | sed 's/:/ /g'`
	# make an array so we can yank out the name and command
	cmd_options_non_dashed=(${non_dashed_no_colon})

	# the container name is the first element
	container_name=${cmd_options_non_dashed[0]}
	check_is_known_container ${container_name}
	if [ $? -eq 1 ]; then
	    echo "ERROR: container ${container_name} is not known"
	    exit 1
	fi

	# remove the first option from the command, we'll be passing it along, unprocessed
	cmd_to_exec="${cmd_options_non_dashed[@]:1}"

	if [ "${container_name}" = "host" ] || [ "${container_name}" = "essential" ]; then
	    if [ -n "${verbose}" ]; then
		echo "running: cube-cmd ${cmd_to_exec[@]}"
	    fi

	    cube-cmd cmd ${cmd_to_exec[@]}
	else
	    mgr=$(cube-cfg -o /opt/container/${container_name}/ get cube.container.mgr)
	    echo ${mgr} | grep -q runc
	    if [ $? -eq 0 ]; then
		cmd="cube-cmd ${mgr} exec -- ${container_name} ${cmd_to_exec}"
	    else
		echo "[ERROR]: container '${container_name} has no container manager identified, not executing command"
		exit 1
	    fi

	    # if the command is interactive, we need to ensure that a terminal is allocated
	    # or it won't work / look like it is hung
	    if [ -n "${interactive}" ]; then
		terminal_flag="t"
	    else
		terminal_flag="f"
	    fi
	    tweak_container_terminal ${container_name} /opt/container ${terminal_flag}

	    if [ -n "${verbose}" ]; then
		echo "running: ${cmd}"
	    fi

	    eval ${cmd}
	fi
	;;
    *)
	echo "Unknown command ..."
	usage_global
	;;
esac

#!/bin/bash

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

mydir=`dirname $0`
PATH=$mydir:$PATH

if [ "$CUBE_DEBUG_SET_X_IF_SET" = 1 ] ; then
    set -x
fi

usage()
{
cat << EOF

 ${0##*/} [--clean] <command> <value>

 global options:
    
   --clean: remove artifacts before performing <command>
   -o     : output/config directory
   -n     : container name

 commands (and options):

 ${0##*/} gen <name>:<type>

    generate a base configuration

       <name>:<type> container name and type

 ${0##*/} show <name>

    show the configuration options for container <name>

 ${0##*/} [-n <container name>] mount <type>:<name>:<name>

    mount a directory into the container

       <type>:       optional "bind" if a bind mount is to be used
       <name>:<name> source and destination directory

 ${0##*/} [-n <container name>] hook <type>:<name>
 ${0##*/} [-n <container name>] hook-script <type>:<name>

    Add a hook into the container lifecycle

       hook         the hook is an executable
       hook-script  the hook is a script

       <type>       type of hook: prestart, poststart or poststop
       <name>       full path to the hook

 ${0##*/} link      <container one>:<port> <container two>:<name> [from <ip or "localhost">]
          link-raw  <container> <command>
          link-edit <container>

     Modify the linkages betwen containers. The runtime linkage is
     completed by the 'cube-ctl stack' command.

       link         ensures that the port of container one is linked
                    (forwarded) to container two.
       link-raw     exports the passed command to a location where
                    cube-ctl stack will process it. The correctness of
                    the command is up to the user
       link-edit    invokes $EDITOR to manipulated the staged link
                    commands.

 ${0##*/} [-n <container name>] device <type>:<name>:<name>

    add a device to a container

       <type>:           network, network-virt, vt
          <name>:<name>  device name in essential : device name in container

       <type>:           whitelist, blacklist
          <name>         name of the device to blacklist/whitelist

       <type>:           console
          <type>:<value> type: tty or vt. value: tty or VT number

 ${0##*/} [-n <container name>] id

    get the unique machine / platform identifier

 ${0##*/} [-n <container name>] attribute [+][-] <attribute>

    associated an attribute with a container. + to add, - to remove.

 ${0##*/} get/set:

   NOTE: variables with embedded / are etcd set/get operations.
   NOTE: --append or --prepend can be used in combination with 'set'

   set:
     ${0##*/} [-n <container name>] [-o <output dir>] set <setting>:<value>
     ${0##*/} [-n <container name>] [-o <output dir>] <setting>:<value>

   get:
     ${0##*/} [-n <container name>] [-o <output dir>] get <setting>
     ${0##*/} [-n <container name>] [-o <output dir>] <setting>:

   clear/delete:
     ${0##*/} [-n <container name>] [-o <output dir>] :<setting>

    valid settings are:

EOF

for K in "${!CONFIG_MAP[@]}"; do
    help_text=$(echo "${CONFIG_MAP[$K]}" | cut -f2 -d\;)
    printf "      %-25s %s\n" "$K" "${help_text}"
done
echo ""
}

declare -A CONFIG_MAP

# The key is the variable value on the command line, followed by the
# variable to set in the database semi-colon help text
#
#  <var> <db var>; <help text>
#
CONFIG_MAP[app]="cube.app;The application to start in the container"
CONFIG_MAP[cube.container.mgr]="cube.container.mgr;The manager for the container: the path to the container runtime"
CONFIG_MAP[cube.console.mgr]="cube.console.mgr;The console manager (if access is not direct): 'tty' or 'screen-tty'"
CONFIG_MAP[cube.device.mgr]="cube.device.mgr;The device manager for the container: essential (static) or detected/standalone"
CONFIG_MAP[autostart]="autostart;The autostart runlevel for the container"
CONFIG_MAP[cube.network.type]="cube.network.type;The type of container networking: static or dynamic"
CONFIG_MAP[cube.network.ip]="cube.network.ip;<ip>/<netmask>. The ip to assign to the container (must be supplied for static network type)"
CONFIG_MAP[cube.network.mac]="cube.network.mac;The mac address to assign to the container interface"
CONFIG_MAP[cube.network.gateway]="cube.network.gateway;The gateway to use for the container"
CONFIG_MAP[cube.network.nameserver]="cube.network.nameserver;The nameserver to use for the container"

if [ -z "$1" ]; then
    usage
    exit
fi

# take the entire command into an array
raw_command=($@)

force=""
peer=t
non_dashed=""
out_dir="./"

# this corresponds to the lxc.id_map items within the container's config file
DEFAULT_SUBUID=800000

while [ $# -gt 0 ]; do
    case "$1" in
	-v) verbose=t
            ;;
	--dryrun)
	    dryrun=t
	    vebose=t
	    ;;
	--clean)
	    clean=t
	    ;;
        --peer)
	    peer=t
	    nested=
	    ;;
	--nested)
	    nested=t
	    peer=
	    ;;
	--parent)
	    parent=${2}
	    shift
	    ;;
	--prepend)
	    # used with set
	    prepend=t
	    ;;
	--append)
	    # used with set
	    append=t
	    ;;
	--name)
	    container_name_temp=${2}
	    shift
	    ;;
	-u)
		# This is an unprivileged container. We need to config subuid/subgid.
		if [ "${2}" -eq "${2}" ] 2>/dev/null; then
			if [ "${2}" -lt 100000 ] 2>/dev/null; then
				echo "Error: -u requires a subuid number no less than 100000"
				exit 1
			fi
			subuid="${2}"
			shift
		else
			subuid="${DEFAULT_SUBUID}"
		fi
		;;
	-F)
	    force=-F
	    ;;
        --n|-n)
	    container_name=${2}
	    shift
	    ;;
        --t|-t)
	    container_type=${2}
	    shift
	    ;;
        --o|-o)
	    out_dir=${2}
	    shift
	    ;;
	-h|--help)
	    usage
	    exit
	    ;;
	--*)
	    # if the next argument is dashed, we just add $1 to our collection
	    # of dashed arguments. If $2 is NOT dashed, we assume it is a parameter
	    # to the --dashed option, and we grab it as well. Don't try and mix
	    # dashed and non-dashed, since we'll grab them!
	    case $2 in
		--*)
		    dashed="${dashed} $1"
		    ;;
		*)
		    # sneak a : in between, so we can split it later
		    dashed="${dashed} $1:$2"
		    shift
		    ;;
	    esac
	    ;;
        *) non_dashed="${non_dashed} $1"
            ;;
    esac
    shift
done

determine_outdir()
{
    # if outdir wasn't passed on the command line, but a container name
    # was passed, then we should check to see if the container is available
    # and change the out_dir to where it is stored. This allows things
    # like: 'cube-cfg -n cube-server get autostart' to work without passing
    # the out_dir explicitly
    if [ "${out_dir}" == "./" ]; then
	if [ -n "${container_name}" ]; then
	    if [ -d "/opt/container/${container_name}" ]; then
		# but only if we have a config.json, should this actually become
		# our outdir
		if [ -f "/opt/container/${container_name}/config.json" ]; then
		    out_dir="/opt/container/${container_name}"
		fi
	    fi
	fi
    fi
}

determine_outdir

# returns 1 if we are container, 0 otherwise
function am_i_a_container()
{
    local virt_bin=$(which systemd-detect-virt)

    # if we can't run detection, just say we aren't a container
    if [ -z "${virt_bin}" ]; then
	return 0
    fi

    local virt=`systemd-detect-virt`
    case $virt in
	lxc*)
	    return 1
	    ;;
	container*)
	    return 1
	    ;;
	docker*)
	    return 1
	    ;;
    esac

    return 0
}

am_i_a_container
if [ $? -eq 1 ]; then
    we_are_a_container=t
fi

# make an array from whatever was non-dashed
cmd_options_non_dashed=(${non_dashed})

if [ -z "${cmd}" ]; then
    # the first element is the command
    cmd=${cmd_options_non_dashed[0]}
fi

check_required()
{
    if [ ! -e "${1}" ]; then
	echo "[ERROR]: required command ${1} not found, exiting"
	exit 1
    fi
}

check_if_present()
{
    if [ -e "${1}" ]; then
	return 0
    fi
    return 1
}

#
# arg1: type of artifacts to clean. if not passed, all will be
#       cleaned
#
clean_config_artifacts()
{
    local type=$1

    if [ -z "${type}" ]; then
	type="all"
    fi

    if [ "${type}" = "mount" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.mount
	rm -f ${out_dir}/.cube.mount.bind
    fi

    if [ "${type}" = "device" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.device ${out_dir}/.cube.device.network ${out_dir}/.cube.device.vt
    fi

    if [ "${type}" = "hooks" ] || [ "${type}" = "all" ]; then
	rm -f ${out_dir}/.cube.hooks.prestart ${out_dir}/.cube.hooks.poststart ${out_dir}/.cube.hooks.poststop
    fi
}

#
# arg1: name of the container
# arg2: type of artifacts to show. 'all' will be assumed if nothing is passed
#
show_config_artifacts()
{
    local container_name=$1
    local type=$2

    if [ -z "${type}" ]; then
	type="all"
    fi

    if [ "${type}" = "mount" ] || [ "${type}" = "all" ]; then
	echo "mounts:"
	echo "-------"
	if [ -e "${out_dir}/.cube.mount" ]; then
	    for b in $(cat ${out_dir}/.cube.mount); do
		echo "mount: $b"
	    done
	fi
	if [ -e "${out_dir}/.cube.mount.bind" ]; then
	    for b in $(cat ${out_dir}/.cube.mount.bind); do
		echo "mount (bind): $b"
	    done
	fi
    fi

    if [ "${type}" = "device" ] || [ "${type}" = "all" ]; then
	echo ""
	echo "devices:"
	echo "--------"
	if [ -e "${out_dir}/.cube.device" ]; then
	    for b in $(cat ${out_dir}/.cube.device); do
		echo "device: $b"
	    done
	fi
	if [ -e "${out_dir}/.cube.device.network" ]; then
	    for b in $(cat ${out_dir}/.cube.device.network); do
		echo "network device: $b"
	    done
	fi
	if [ -e "${out_dir}/.cube.device.vt" ]; then
	    for b in $(cat ${out_dir}/.cube.device.vt); do
		echo "VT device: $b"
	    done
	fi
    fi

    if [ "${type}" = "hooks" ] || [ "${type}" = "all" ]; then
	echo ""
	echo "hooks:"
	echo "------"
	if [ -e "${out_dir}/.cube.hooks.prestart" ]; then
OLDIFS=$IFS
IFS='
'
	    for b in $(cat ${out_dir}/.cube.hooks.prestart); do
		echo "hook (pre start) : $b" | sed 's/##space##//g'
	    done
	fi
	if [ -e "${out_dir}/.cube.hooks.poststart" ]; then
	    for b in $(cat ${out_dir}/.cube.hooks.poststart); do
		echo "hook (post start) : $b" | sed 's/##space##//g'
	    done
	fi
	if [ -e "${out_dir}/.cube.hooks.poststop" ]; then
	    for b in $(cat ${out_dir}/.cube.hooks.poststop); do
		echo "hook (post stop): $b" | sed 's/##space##//g'
	    done
	fi
IFS=$OLDIFS
    fi

    if [ -e "${out_dir}/cube.attributes" ]; then
	echo ""
	echo "attributes:"
	echo "-----------"
	cat "${out_dir}/cube.attributes"
	echo ""
    fi

    echo ""
    output=$(mktemp)
    echo "option:setting" > ${output}
    echo "------:-------" >> ${output}
    for K in "${!CONFIG_MAP[@]}"; do
	echo -n "${K}: " >> ${output}
	value=$(cube-cfg -n ${container_name} get ${K})
	if [ -n "${value}" ]; then
	    echo "${value}" >> ${output}
	else
	    echo "not set" >> ${output}
	fi
    done
    cat ${output} | column -t -s:
    rm ${output}
}

#
# arg1: container name
#
# output: config.json in the current directory
#
generate_base_config()
{
    local container_name=$1

    if [ -e ".cube.mount.bind" ]; then
	for d in $(cat .cube.mount.bind); do
	    mount_args="${mount_args} --mount-bind $d"
	done
    fi

    # temp. once the oci-runtime-tool is updated, we can pass devices
    #       directly. for now this is a bind mount.
    if [ -e ".cube.device.vt" ]; then
	for d in $(cat .cube.device.vt); do
	    mount_args="${mount_args} --mount-bind ${d}"
	done
    fi

    # TODO: these can also be cube-cfg values, but right now are
    #       restricted for compatibility reasons
    capabilities="--process-cap-add CAP_KILL \
		  --process-cap-add CAP_LINUX_IMMUTABLE \
                  --process-cap-add CAP_SYS_RAWIO \
                  --process-cap-add CAP_SYS_ADMIN \
		  --process-cap-add CAP_SYS_MODULE \
                  --process-cap-add CAP_SYS_RESOURCE \
                  --process-cap-add CAP_NET_ADMIN \
                  --process-cap-add CAP_NET_BROADCAST \
                  --process-cap-add CAP_SYSLOG \
                  --process-cap-add CAP_SYS_TTY_CONFIG"

    app="/sbin/init"
    if [ -e "cube.app" ]; then
	app=$(cat cube.app)
    fi

    OLDIFS=$IFS
IFS='
'
    if [ -e ".cube.hooks.prestart" ]; then
	for hook in $(cat .cube.hooks.prestart); do
	    cmd=$(echo ${hook} | cut -d' ' -f1)
	    count=$(echo ${hook} | wc -w)
	    if [ $count -gt 1 ]; then
		# the oci generation tool will take : separated items as arguments
		# to the main executable. So we replace our spaces with : to get
		# everything into the config.json
		args=$(echo ${hook} | sed 's/ /:/g')
		hooks="${hooks} --hooks-prestart ${cmd}:${args}"
	    else
		hooks="${hooks} --hooks-prestart ${cmd}"
	    fi
	done
    fi
    if [ -e ".cube.hooks.poststart" ]; then
	for hook in $(cat .cube.hooks.poststart); do
	    cmd=$(echo ${hook} | cut -d' ' -f1)
	    count=$(echo ${hook} | wc -w)
	    if [ $count -gt 1 ]; then
		# the oci generation tool will take : separated items as arguments
		# to the main executable. So we replace our spaces with : to get
		# everything into the config.json
		args=$(echo ${hook} | sed 's/ /:/g')
		hooks="${hooks} --hooks-poststart ${cmd}:${args}"
	    else
		hooks="${hooks} --hooks-poststart ${cmd}"
	    fi
	done
    fi
    if [ -e ".cube.hooks.poststop" ]; then
	for hook in $(cat .cube.hooks.poststop); do
	    cmd=$(echo ${hook} | cut -d' ' -f1)
	    count=$(echo ${hook} | wc -w)
	    if [ $count -gt 1 ]; then
		# the oci generation tool will take : separated items as arguments
		# to the main executable. So we replace our spaces with : to get
		# everything into the config.json
		args=$(echo ${hook} | sed 's/ /:/g')
		hooks="${hooks} --hooks-poststop ${cmd}:${args}"
	    else
		hooks="${hooks} --hooks-poststop ${cmd}"
	    fi
	done
    fi
    IFS=$OLDIFS

    if [ -z "${hooks}" ]; then
	# if no hooks have been passed, but the app is not /sbin/init
	# we don't need the systemd hook, just go with the network one
	if [ "${app}" = "/sbin/init" ]; then
	    hooks="--hooks-prestart /usr/libexec/oci/hooks.d/oci-systemd-hook \
	           --hooks-poststop /usrlibexec/oci/hooks.d/oci-systemd-hook"
	fi
	hooks="${hooks} --hooks-prestart /usr/libexec/oci/hooks.d/netns"
    fi

    console_mgr=$(cube-cfg cube.console.mgr:)
    if [ "${console_mgr}" = "tty" ]; then
	tty_flag="--process-tty"
    fi

    ## TODO: if there's no oci-runtime-tool, then we should capture a
    ##       a default config.json and modify it on the fly
    oci-runtime-tool generate \
	             ${tty_flag} \
	             ${hooks} \
		     --args ${app} \
                     --linux-seccomp-remove-all \
                     --hostname=${container_name} \
		     --env container=docker \
                     ${capabilities} \
                     ${mount_args} \
                     > config.json.tmp
    if [ ! -s config.json.tmp ] ; then
	echo "ERROR: config.jason generation failed"
	exit 1
    fi

    # fixup: disable seccomp completely by making it a section that is ignored
    sed -i 's/\"seccomp\"/\"seccomp-ignore\"/g' config.json.tmp
    # fixup: "devices" must be available for mods
    sed -i 's/\"allow\": false,/\"allow\": true,/g' config.json.tmp
    # fixup: /sys/ needs to be read-write
    sed -i 's/\"ro\"/\"rw\"/g' config.json.tmp

    # fixup: hooks have been encoded with ##space## to get the arguments properly
    #        into the json for shell script hooks. We need to change these back to
    #        real spaces.
    sed -i 's/\#\#space\#\#/ /g' config.json.tmp    

    mv config.json.tmp config.json

    # by default, we assume runc will manage the container, this can
    # be changed later.
    if [ ! -e cube.container.mgr ]; then
	echo "runc" > cube.container.mgr
    fi

    # Generate an oci.cmd that can be used to launch this container via runc
    echo "#!/bin/bash" > oci.cmd
    if [ "${console_mgr}" = "tty" ] || [ "${console_mgr}" = "screen-tty" ]; then
	runc_console="--console-socket=/var/lib/cube/$container_name/runc-sock"
	echo "rm -f /var/lib/cube/${container_name}/dtach-sock /var/lib/cube/${container_name}/runc-sock" >> oci.cmd
	echo "/usr/bin/dtach -n /var/lib/cube/${container_name}/dtach-sock -W 120 -p /var/lib/cube/${container_name}/pty-console -c -C -E -q /var/lib/cube/${container_name}/runc-sock" >> oci.cmd
	jq -r  '.process.terminal = true' config.json > config.json.terminal
    else
	jq -r  '.process.terminal = false' config.json > config.json.terminal
    fi
    echo "mgr=\$(cat /opt/container/${container_name}/cube.container.mgr)" >> oci.cmd
    mv config.json.terminal config.json
    echo "\${mgr} create --bundle /opt/container/${container_name} ${runc_console} ${container_name}" >> oci.cmd
    if [ "${console_mgr}" = "screen-tty" ]; then
	echo "/usr/bin/screen -ls console > /dev/null && /usr/bin/screen -S console -x -X screen -t ${container_name} /var/lib/cube/${container_name}/pty-console" >> oci.cmd
    fi
    echo "\${mgr} start ${container_name}" >> oci.cmd
    chmod +x oci.cmd
}

#
# arg1: container name
#
convert_base_config_to_cube()
{
    local container_name=$1

    rm -f pflask.config

    # any mounts ?
    for mount in $(jq -r '.mounts | map("\(.type):\(.source):\(.destination)") | .[]' config.json); do
	# we only care about bind mounts at the moment
	echo "$mount" | grep -q bind
	if [ $? -eq 0 ]; then
	    echo ${mount} >> pflask.config
	    pflask_args="${pflask_args} --mount ${mount}"
	fi
    done

    # any devices.
    # TODO: these need to come from the oci spec, like the mounts, but right
    #       now the OCI tool doesn't seem to handle it
    if [ -e ".cube.device.network" ]; then
	netdevs=$(cat .cube.device.network)
	for n in ${netdevs}; do
	    pflask_args="${pflask_args} --netif=${n}"
	done
	echo "${netdevs}" >> pflask.config
    fi

    # hooks ?
    poststart_hooks=$(jq -r '.hooks.poststart' config.json)
    if [ "${poststart_hooks}" != "null" ]; then
	poststart_hooks=$(jq -r '.hooks.poststart | map("\(.path) \(.args)") | . []' config.json)
    fi
    poststop_hooks=$(jq -r '.hooks.poststop' config.json)
    if [ "${poststop_hooks}" != "null" ]; then
	poststopt_hooks=$(jq -r '.hooks.poststop| map("\(.path) \(.args)") | . []' config.json)
    fi

    # what is the executable we are running ?
    app=$(jq -r  '.process.args | .[]' config.json)

    # and the root directory (to be appended to the current working dir)
    rootfs=$(jq -r  '.root.path'  config.json)
    rootfs="/opt/container/${container_name}/${rootfs}"

    pflask_args="${pflask_args}	-p ${container_name} --uncontain -d --escape-char=255 --root ${rootfs}"

    echo "#!/bin/bash" > pflask.cmd
    echo "date > /tmp/pflask-hook.log" >> pflask.cmd

    if [ -e "cube.console.mgr" ]; then
	grep -q "screen-tty" cube.console.mgr
	if [ $? -eq 0 ]; then
	    # The %d in the pflask command line is a sentinel value to trigger
	    # pflask to attach to it's pid (through the console command). This
	    # only works in background mode.
	    echo "export CONSOLE_CMD=\"[ -d /tmp/screens ] && /usr/bin/screen -S console -x -X screen -t ${container_name} /bin/pflask -a %d -E 255\"" >> pflask.cmd
	fi
    fi
    echo "pflask ${pflask_args} -- ${app}" >> pflask.cmd

    if [ -n "${poststart_hooks}" ]; then
	OLDIFS=$IFS
IFS='
'
	for h in ${poststart_hooks}; do
	    # drop any "null" strings, since that means "no args"
	    h=$(echo "${h}" | sed 's/null//g')

	    # args are in an array i.e. ["sh","-c","/usr/libexec/oci/hooks.d/oci-network down $(cat)"]
	    # so we test for the brackets and replace the hook with the output
	    echo "${h}" | grep -q "\["
	    if [ $? -eq 0 ]; then
		zztop=$(echo ${h} | sed -e 's/.*\[\(.*\)\]/\1/')
		if [ -n "${zztop}" ]; then
		    # drop quotes and commas
		    zztop=$(echo ${zztop} | tr -d '"')
		    zztop=$(echo ${zztop} | sed 's/,/ /g')
		    h=${zztop}
		fi
	    fi

	    # was it a script call ? if it was, we need to put quotes back
	    # arond the -c "<command>"
	    echo ${h} | grep -q "sh -c"
	    if [ $? -eq 0 ]; then
		h=$(echo ${h} | sed "s/-c /-c '/")
		h=$(echo ${h} | sed "s/$/'/")
	    fi

	    # put the conditioned hook into the pflask command, with a retry loop (since these can have timing issues)
	    echo "count=0" >> pflask.cmd
	    echo "while [ \$count -lt 10 ]; do" >> pflask.cmd
	    echo "    ${h}" >> pflask.cmd
	    echo "    if [ \$? -ne 0 ]; then" >> pflask.cmd
	    echo "        echo \"Hook fail [\"${h}\"] (\$count)!\" >> /tmp/pflask-hook.log" >> pflask.cmd
	    echo "        count=\`expr \$count + 1\`" >> pflask.cmd
	    echo "        sleep 0.5" >> pflask.cmd
	    echo "    else" >> pflask.cmd
	    echo "        echo \"Hook success [\"${h}\"] (\$count)\" >> /tmp/pflask-hook.log" >> pflask.cmd
	    echo "        count=10" >> pflask.cmd
	    echo "    fi" >> pflask.cmd
	    echo "done" >> pflask.cmd
	done
	IFS=$OLDIFS
    fi

    chmod +x pflask.cmd
    echo "pflask" > cube.container.mgr
}

etcd_fetch()
{
    local key=$1

    local key_dir=$(dirname ${key})
    local key_name=$(basename ${key})
    local etcdctl=etcdctl

    if [ -n "${dryrun}" ]; then
	etcdctl="echo etcdctl"
    fi

    if [ -n "${verbose}" ]; then
	echo "[INFO]: fetching ${key}"
    fi

    eval ${etcdctl} get ${key_dir}/${key_name}
    if [ $? -ne 0 ]; then
	echo "ERROR: Could not inject ${key} to etcd data store"
	return
    fi
}

# inputs:
#    1: file to check
#    2: value we are looking for
#
# return:
#    0: not set
#    1: is set
check_isset() {
    file_to_check=$1
    shift
    value_to_check=$@

    if [ -e ${file_to_check} ]; then
	cat ${file_to_check} | grep -q -w "${value_to_check}"
	if [ $? -eq 0 ]; then
	    return 1
	fi
    fi

    return 0
}

etcd_inject()
{
    local key=$1
    local value=$2

    local key_dir=$(dirname ${key})
    local key_name=$(basename ${key})
    local etcdctl=etcdctl

    redir="> /dev/null"
    if [ -n "${dryrun}" ]; then
	etcdctl="echo etcdctl"
	redir=""
    fi

    if [ -n "${verbose}" ]; then
	echo "[INFO]: injecting ${key}:${value}"
    fi

    if [ -n "${value}" ]; then
	eval ${etcdctl} set ${key_dir}/${key_name} ${value} $redir
	if [ $? -ne 0 ]; then
	    echo "ERROR: Could not inject ${key} to etcd data store"
	    return
	fi
    else
	# value isn't set, we are clearing the key
	eval ${etcdctl} rm -r ${key} ${value} $redir
    fi
}

case "${cmd}" in
    clean)
	clean_config_artifacts
	;;
    show)
	if [ -z "${container_name}" ]; then
	    echo "[ERROR]: a container name must be provided"
	fi
	show_config_artifacts ${container_name}
	;;
    gen)
	name_temp=${cmd_options_non_dashed[1]}
	container_name=$(echo ${name_temp} | cut -f1 -d:)
	container_type=$(echo ${name_temp} | cut -f2 -d:)

	determine_outdir

	if [ "${container_name}" == "${container_type}" ]; then
	    container_type="oci"
	fi

	(
	    cd ${out_dir}
	    generate_base_config ${container_name}
	)

	if [ "${container_type}" == "cube" ]; then
	    convert_base_config_to_cube ${container_name}
	fi
	;;
    mount)
	name_temp=${cmd_options_non_dashed[1]}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts mount
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 2 ]; then
	    # we have <type>:<source>:<dest>
	    type=$(echo ${name_temp} | cut -f1 -d:)
	    source=$(echo ${name_temp} | cut -f2 -d:)
	    dest=$(echo ${name_temp} | cut -f3 -d:)

	    outfile="${out_dir}/.cube.mount.bind"
	    op_test="${type}"
	elif [ ${colons} -eq 1 ]; then
	    # we have <source>:<dest>
	    type="standard"
	    source=$(echo ${name_temp} | cut -f1 -d:)
	    dest=$(echo ${name_temp} | cut -f2 -d:)

	    if [ "${source}" == "bind" ]; then
		# this was really bind mount missing an argument
		echo "[ERROR]: bind mounts require a source and destination argument"
		exit 1
	    fi

	    outfile="${out_dir}/.cube.mount"
	    op_test="${source}"
	else
	    # we dump the mounts
	    type=$(echo ${name_temp} | cut -f1 -d:)
	    if [ "${type}" == "bind" ]; then
		if [ -e "${out_dir}/.cube.mount.bind" ]; then
		    cat "${out_dir}/.cube.mount.bind"
		fi
	    else
		if [ -e "${out_dir}/.cube.mount" ]; then
		    cat "${out_dir}/.cube.mount"
		fi
	    fi
	    exit 0
	fi

	if [ -z "${source}" ]; then
	    echo "[ERROR]: no source mount provided"
	    exit 1
	fi
	if [ -z "${dest}" ]; then
	    echo "[ERROR]: no dest mount provided"
	    exit 1
	fi

	if [ -n "${op_test}" ]; then
	    # was there a + or - as part of the container_a ?
	    case ${op_test} in
		-*)
		    op_test=$(echo ${op_test} | sed 's/^-//')
		    op="-"
		    ;;
		+*)
		    op_test=$(echo ${op_test} | sed 's/^+//')
		    op="+"
		    ;;
		*)
		    op="+"
		    ;;
	    esac
	fi

	if [ "${type}" == "standard" ]; then
	    source="${op_test}"
	else
	    type="${op_test}"
	fi

	if [ "${op}" == "+" ]; then
	    if [ -n "${verbose}" ]; then
		echo "[INFO]: adding mount ${source} -> ${dest}"
	    fi

	    check_isset ${outfile} "${source}:${dest}"
	    if [ $? -eq 0 ]; then
		echo "${source}:${dest}" >> ${outfile}
	    fi
	else
	    if [ -n "${verbose}" ]; then
		echo "[INFO]: removing mount ${source} -> ${dest}"
	    fi
	    sed "\|^${source}:${dest}$|d" -i ${outfile}
	fi
	;;
    id)
	if [ -e /etc/machine-id ]; then
	    cat /etc/machine-id
	else
	    echo ""
	fi
	;;
    link)
	container_a=${cmd_options_non_dashed[1]}
	container_b=${cmd_options_non_dashed[2]}

	from=${cmd_options_non_dashed[3]}
	from_ip=${cmd_options_non_dashed[4]}

	container_a_port=$(echo ${container_a} | cut -f2 -d:)
	container_b_port=$(echo ${container_b} | cut -f2 -d:)
	container_a=$(echo ${container_a} | cut -f1 -d:)
	container_b=$(echo ${container_b} | cut -f1 -d:)

	container_name=${container_a}
	determine_outdir

	if [ -n "${container_a}" ]; then
	    # was there a + or - as part of the container_a ?
	    case ${container_a} in
		-*)
		    container_a=$(echo ${container_a} | sed 's/^-//')
		    op="-"
		    ;;
		+*)
		    container_a=$(echo ${container_a} | sed 's/^+//')
		    op="+"
		    ;;
		*)
		    container_a=${container_a}
		    op="+"
		    ;;
	    esac
	fi

	if [ -n "${from}" ]; then
	    if [ -z "${from_ip}" ]; then
		echo "[ERROR]: 'from' requires a source IP address"
		exit 1
	    fi

	    if [ "${from_ip}" == "localhost" ]; then
		from_ip="127.0.0.1"
		localhost=t
	    else
		source_args="-s ${from_ip}"
	    fi
	fi

	if [ -n "${localhost}" ]; then
	    cmd_1="sysctl -w net.ipv4.conf.all.route_localnet=1"
	    cmd_2="iptables -A OUTPUT -t nat -p tcp --dport ${container_a_port} -j DNAT --to \${${container_b}_ip}:${container_b_port}"
	else
	    cmd_1="iptables -A PREROUTING -t nat -i \${device} -p tcp ${source_args} --dport ${container_a_port} -j DNAT --to \${${container_b}_ip}:${container_b_port}"
	    cmd_2="iptables -A FORWARD -p tcp -d \${${container_b}_ip}  ${source_args} --dport ${container_b_port} -j ACCEPT"
	fi

	if [ "${op}" == "+" ]; then
	    if [ -n "${verbose}" ]; then
		echo "[INFO]: linking $container_a $container_a_port to $container_b $container_b_port"
	    fi

	    # TODO. The number of commands needs to be dynamic ..but for now, we'll keep it simple
	    check_isset ${out_dir}/cube.network.stack $cmd_1
	    if [ $? -eq 0 ]; then
		echo "${cmd_1}" >> ${out_dir}/cube.network.stack
		echo "${cmd_2}" >> ${out_dir}/cube.network.stack
	    fi
	else
	    if [ -n "${verbose}" ]; then
		echo "[INFO]: removing link from $container_a $container_a_port to $container_b $container_b_port"
	    fi
	    sed "\|${cmd_1}|d" -i ${out_dir}/cube.network.stack
	    sed "\|${cmd_2}|d" -i ${out_dir}/cube.network.stack
	fi
	;;
    link-raw)
	container=${cmd_options_non_dashed[1]}
	command=${cmd_options_non_dashed[@]:2}
	if [ -d "${out_dir}/${container}" ]; then
	    eval echo ${command} >> ${out_dir}/${container}/cube.network.stack
	fi
	;;
    link-edit)
	container=${cmd_options_non_dashed[1]}
	if [ -d "${out_dir}/${container}" ]; then
	    if [ -z "${EDITOR}" ]; then
		EDITOR=vim
	    fi
	    ${EDITOR} ${out_dir}/${container}/cube.network.stack
	fi
	;;
    attribute)
	op=${cmd_options_non_dashed[1]}
	attribute=${cmd_options_non_dashed[2]}

	if [ -z "${attribute}" ]; then
	    # was there a + or - as part of the attribute ?
	    case ${op} in
		-*)
		    attribute=$(echo ${op} | sed 's/^-//')
		    op="-"
		    ;;
		+*)
		    attribute=$(echo ${op} | sed 's/^+//')
		    op="+"
		    ;;
		*)
		    attribute=${op}
		    op=""
		    ;;
	    esac
	fi

	if [ -z "${op}" ] && [ -z "${attribute}" ]; then
	    # we should output the attributes if they exist
	    if [ -e ${out_dir}/cube.attributes ]; then
		cat ${out_dir}/cube.attributes
	    fi
	    exit 0
	fi
	if [ -z "${op}" ]; then
	    echo "ERROR: no operation was specified (+ or -)"
	    exit 1
	fi
	if [ -z "${attribute}" ]; then
	    echo "ERROR: no attribute was specified"
	    exit 1
	fi

	## TODO combine this with the get/set code below, since this really
	## is just a variant that uses append/remove
	if [ -e ${out_dir}/cube.attributes ]; then
	    cat ${out_dir}/cube.attributes | grep -q -w ${attribute}
	    if [ $? -eq 0 ]; then
		alreadyset=t
	    fi
	fi
	case ${op} in
	    +)
		if [ -z "${alreadyset}" ]; then
		    echo -n "${attribute} " >> ${out_dir}/cube.attributes
		fi
		;;
	    -)
		if [ -n "${alreadyset}" ]; then
		    sed "s/${attribute}//g" -i ${out_dir}/cube.attributes
		fi
		;;
	esac
	;;
    hook|hook-script)
	# drop "hook" from the command options, and then output everything
	# after it. We'll have a <type>:<command> in name_temp.
	name_temp=${cmd_options_non_dashed[@]:1}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts hooks
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if [ ${colons} -eq 1 ]; then
	    # we have <source>:<dest>
	    type=$(echo ${name_temp} | cut -f1 -d:)
	    hookname=$(echo ${name_temp} | cut -f2 -d:)

	    # danger! repeated code, this needs to be unified with the attributes
	    #         and device code.
	    if [ -n "${type}" ]; then
		# was there a + or - as part of the hook type ?
		case ${type} in
		    -*)
			type=$(echo ${type} | sed 's/^-//')
			op="-"
			;;
		    +*)
			type=$(echo ${type} | sed 's/^+//')
			op="+"
			;;
		    *)
			op="+"
		    ;;
		esac
	    fi

	    if [ "${cmd}" == "hook-script" ]; then
		# When we later generate hooks, spaces in the hook definition
		# are processed as args to the executable. Due to the way
		# that shell scripts are invoked as hooks, we need all of the
		# script paramaters to be a single arg. To make sure this
		# happens, we replaces spaces with a placeholder ##space##
		# that will be converted back to spaces later
		hookname=$(echo ${hookname} | sed 's/ /##space##/g')
		hookname="/bin/sh -c ${hookname}"
	    fi

	    if [ "${type}" == "prestart" ]; then
		outfile="${out_dir}/.cube.hooks.prestart"
	    elif [ "${type}" == "poststart" ]; then
		outfile="${out_dir}/.cube.hooks.poststart"
	    elif [ "${type}" == "poststop" ]; then
		outfile="${out_dir}/.cube.hooks.poststop"
	    else
		echo "ERROR: invalid hook type specified ${type}"
		exit 1
	    fi

	    if [ "${op}" == "+" ]; then
		check_isset ${outfile} ${hookname}
		if [ $? -eq 0 ]; then
		    # it isn't already set
		    echo "${hookname}" >> ${outfile}
		fi
	    else
		sed "\|^${hookname}$|d" -i ${outfile}
	    fi
	else
	    echo "ERROR: Invalid hook specified ${name_temp}"
	    exit 1
	fi
	;;
    device|dev)
	name_temp=${cmd_options_non_dashed[1]}

	if [ -n "${clean}" ]; then
	    clean_config_artifacts device
	fi

	colons=$(echo ${name_temp} | sed -e 's/\(.\)/\1\n/g' | grep : | wc -l)
	if  [ ${colons} -eq 0 ]; then
	    # this is a get, i.e. cube-cfg device vt
	    device_type=${name_temp}
	    if [ -e "${out_dir}/.cube.device.${device_type}" ]; then
		cat "${out_dir}/.cube.device.${device_type}"
	    else
		echo ""
	    fi
	elif [ ${colons} -eq 2 ]; then
	    # we have <type>:<source>:<dest>
	    device_type=$(echo ${name_temp} | cut -f1 -d:)
	    essential_device=$(echo ${name_temp} | cut -f2 -d:)
	    container_device=$(echo ${name_temp} | cut -f3 -d:)

	    if [ -n "${device_type}" ]; then
		# was there a + or - as part of the device ?
		case ${device_type} in
		    -*)
			device_type=$(echo ${device_type} | sed 's/^-//')
			op="-"
			;;
		    +*)
			device_type=$(echo ${device_type} | sed 's/^+//')
			op="+"
			;;
		    *)
			op="+"
			;;
		esac
	    fi

	    # save the mount information for the generation phase
	    case "${device_type}" in
		network)
		    check_isset ${out_dir}/.cube.device.network "$essential_device:$container_device"
		    if [ $? -eq 1 ]; then
			alreadyset=t
		    fi
		    case ${op} in
			+)
			    if [ -z "${alreadyset}" ]; then
				echo "$essential_device:$container_device"  >> ${out_dir}/.cube.device.network
			    fi
			    ;;
			-)
			    if [ -n "${alreadyset}" ]; then
				sed "/^${essential_device}:${container_device}$/d" -i ${out_dir}/.cube.device.network
			    fi
			    ;;
		    esac
		    ;;
		network-virt)
		    check_isset ${out_dir}/.cube.device.network "veth:$essential_device:$container_device"
		    if [ $? -eq 1 ]; then
			alreadyset=t
		    fi
		    case ${op} in
			+)
			    if [ -z "${alreadyset}" ]; then
				echo "veth:$essential_device:$container_device"  >> ${out_dir}/.cube.device.network
			    fi
			    ;;
			-)
			    if [ -n "${alreadyset}" ]; then
				sed "/^veth:${essential_device}:${container_device}$/d" -i ${out_dir}/.cube.device.network
			    fi
			    ;;
		    esac
		    ;;
		vt)
		    echo "$essential_device:$container_device"  >> ${out_dir}/.cube.device.vt
		    ;;
	    esac
	else
	    echo "ERROR: Invalid device specified ${name_temp}"
	    exit 1
	fi
	;;
    set|get)
	;&
    *:*)
	var_value=${cmd_options_non_dashed[1]}
	if [ -z "${var_value}" ]; then
	    var_value="${cmd}"
	    var=$(echo ${var_value} | cut -d: -f1)
	    value=$(echo ${var_value} | cut -d: -f2)

	    # set or get wasn't passed on the command line, so we determine
	    # if this is set or get based on which values are empty.

	    # - if both are defined, then this is a set
	    # - if only the var is defined, then this is a get
	    # - if only the value is defined, it is a clear/delete
	    #   and the value is actually the variable
	    if [ -n "${var}" ] && [ -n "${value}" ]; then
		cmd="set"
	    elif [ -n "${var}" ] && [ -z "${value}" ]; then
		cmd="get"
	    elif [ -z "${var}" ] && [ -n "${value}" ]; then
		# this is a delete operation
		cmd="set"
		var=$value
		value=""
	    fi
	else
	    var=$(echo ${var_value} | cut -d: -f1)
	    value=$(echo ${var_value} | cut -d: -f2)
	fi

	# danger! repeated code, this needs to be unified with the attributes
	#         and device code.
	if [ -n "${var}" ]; then
	    # was there a + or - as part of the variable name ?
	    case ${var} in
		-*)
		    var=$(echo ${var} | sed 's/^-//')
		    op="-"
		    ;;
		+*)
		    var=$(echo ${var} | sed 's/^+//')
		    op="+"
		    ;;
		*)
		    op="+"
		    ;;
	    esac
	fi

	if [ -z "${CONFIG_MAP[$var]}" ]; then
	    echo $var | grep -q /
	    if [ $? -ne 0 ]; then
		echo "[ERROR]: '$var' is not a known setting"
		exit 1
	    else
		etcd=t
		db_var="$var"
	    fi
	else
	    db_var=$(echo "${CONFIG_MAP[$var]}" | cut -f1 -d\;)
	fi

	# note: the backend that stores these values will change over time
	#       for now, it is a simple on-disk file. It could be a git config
	#       format file, etcd, or a database in the future

	if [ -n "${etcd}" ]; then
	    # if there's a / in the variable, it is destined for a data
	    # store. Note: this could also be a flag to the call, i.e. --etcd
	    # but lets go with this for now
	    if [ ${cmd} = "set" ]; then
		## TODO: if "value" is empty we should be deleting the key, right now
		##       there is no way to do it.
		etcd_inject ${var} ${value}
	    else
		etcd_fetch ${var}
	    fi
	else
	    if [ "${cmd}" = "set" ]; then
		if [ -f ${out_dir}/${db_var} ]; then
		    previous=$(cat ${out_dir}/${db_var})
		fi

		if [ "${op}" == "+" ]; then
		    if [ -n "${prepend}" ]; then
			echo "${value} ${previous}" > ${out_dir}/${db_var}
		    elif [ -n "${append}" ]; then
			echo "${previous} ${value}" > ${out_dir}/${db_var}
		    else
			echo "${value}" > ${out_dir}/${db_var}
		    fi
		else
		    sed "s%${value} *%%g" -i ${out_dir}/${db_var}
		fi
	    else
		if [ -e "${out_dir}/${db_var}" ]; then
		    cat "${out_dir}/${db_var}"
		else
		    echo ""
		fi
	    fi
	fi
	;;
    *)
	echo "Unknown command ..."
	usage
	;;
esac

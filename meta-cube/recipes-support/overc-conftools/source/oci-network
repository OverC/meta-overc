#/bin/bash

# we ge an action + startup json
action=$1
shift

# yank what we need out of the json
pid=$(echo "$@" | jq .pid)
veth_name=$(eval echo veth${pid})

if [ "${action}" = "up" ]; then
    echo "${pid}" > .cube.pid
    echo "${veth_name}" > .cube.veth
    cname=$(basename `pwd`)

    network=dynamic
    if [ -f cube.network.type ]; then
	network=$(cat cube.network.type)
    fi

    # This creates a veth pair.
    #
    #    veth<container namespace> -> veth-br-int
    #
    # veth<container namespace> remains in essential, and we use the container
    # namespace so we can always locate the container ns later, and so that it
    # is unique within essential.
    #
    # veth-br-int is inserted into the container, and will be consistent across
    # containers.
    #
    ip link add dev ${veth_name} type veth peer name veth-br-int
    
    # Add the veth that stays in essential to the ovs-bridge. This gets us
    # connectivity to the network prime, and hence the outside world
    ovs-vsctl add-port br-int ${veth_name}

    # Bring up the interface we just added to the bridge. It must be up so dhcp
    # can get an ip address.
    ip link set dev ${veth_name} up

    # push the container veth endpoint into the container network namespace
    ip link set veth-br-int netns ${pid}

    # TODO: we should have a third networking mode "self", which means that
    #       we'd make the veth available and let the container itself set up
    #       the networking (presumably via dhcp). This currently has issues
    #       with systemd lacking permissions and capabilities.
    #
    # Configure the container networking:
    #   1) loopback interface
    #   2) dhcp address for the veth-br-int
    #   3) default route configuration
    #
    nsenter -t ${pid} -n --preserve-credentials ip link set dev lo up
    nsenter -t ${pid} -n --preserve-credentials ip link set dev veth-br-int up

    if [ "${network}" == "dynamic" ]; then
	command="dhclient -sf /usr/sbin/dhclient-script.container -e CONTAINER=${cname} --no-pid veth-br-int >> /dev/null 2>&1"
	eval nsenter -t ${pid} -n -- ${command}
	if [ -e "/etc/resolv.conf.${cname}" ]; then
	    mv /etc/resolv.conf.${cname} /opt/container/${cname}/rootfs/etc/resolv.conf
	fi
	primary_ip=$(nsenter -t ${pid} -n ip -o -4 addr list veth-br-int | awk '{print $4}' | cut -d/ -f1)
    else
	# the ip must be in the format of address/mask, i.e.: 192.168.42.101/24
	ip=$(cat cube.network.ip)
	if [ -z "${ip}" ]; then
	    echo "ERROR: static networking selected and no IP provided"
	    exit 1
	fi

	# the first entry is the primary, any others are aliases
	count=0
	for i in ${ip}; do
	    if [ ${count} -eq 0 ]; then
		nsenter -t ${pid} -n --preserve-credentials ip addr add $i dev veth-br-int
		primary_ip=$(echo $i | cut -d/ -f1)
	    else
		nsenter -t ${pid} -n --preserve-credentials ip addr add $i dev veth-br-int:${count}
	    fi
	    let count=${count}+1
	done
    fi

    if [ -f "cube.network.mac" ]; then
	mac_address=$(cat cube.network.mac)
    else
	# OCI's use the internal mac range: xA-xx-xx-xx-xx-xx
	last_ip_range=$(echo $primary_ip | cut -f4 -d.)
	mac_address=$(printf "0A:00:00:00:00:%02x" ${last_ip_range})
    fi
    nsenter -t ${pid} -n --preserve-credentials ip link set dev veth-br-int up address ${mac_address}

    gateway="192.168.42.1"
    if [ -f "cube.network.gateway" ]; then
	gateway=$(cat cube.network.gateway)
    fi

    # physical device passthrough
    if [ -f ".cube.device.network" ]; then
	# any non virtual ethernet devices ?
	netdevs=$(cat .cube.device.network)
	# Expand any network+ args
	netdevsexp=""
	for n in ${netdevs}; do
		if [ "${n}" = "${n/+/}" ] ; then
			netdevsexp="$n $netdevsexp"
		else
			device=$(echo ${n} | cut -f1 -d+)
			for nd in `ip -o link  |awk -F: '{print $2}'`; do
				if [ "$nd" != "${nd#$device}" ] ; then
					netdevsexp="$nd:$nd $netdevsexp"
				fi
			done
		fi
	done
	for n in ${netdevsexp}; do
	    echo ${n} | grep -q veth
	    if [ $? -ne 0 ]; then
		# we have a real device
		device=$(echo ${n} | cut -f1 -d:)
		# push the device into the namespace
		# If we are asked to move a wireless interface, 
		# then we must actually move its phyN device using
		# iw command.
		phyname=""
		if [ -f "/sys/class/net/$device/phy80211/name" ]; then
			phyname=`cat /sys/class/net/$device/phy80211/name`
		fi
		if [ -n "$phyname" ]; then
			iw phy $phyname set netns ${pid}
		else
			ip link set ${device} netns ${pid}
		fi
		nsenter -t ${pid} -n --preserve-credentials ip link set dev ${device} up

		# setup nat and forwarding. this is what systemd-networkd does as well
		nsenter -t ${pid} -n --preserve-credentials iptables -t nat -A POSTROUTING -o ${device} -j MASQUERADE
		nsenter -t ${pid} -m -n -u -i -p -C --preserve-credentials sh -c 'echo 1 > /proc/sys/net/ipv4/ip_forward'
	    fi
	done
    else
	nsenter -t ${pid} -n --preserve-credentials ip route add default via ${gateway}
    fi

    # note: this should be conditional with the fixed dhclient call above
    nameserver="192.168.42.1"
    if [ -f "cube.network.nameserver" ]; then
	nameserver=$(cat cube.network.nameserver)
    fi
    nsenter -t ${pid} -m sh -c "rm -f /etc/resolv.conf"
    nsenter -t ${pid} -m sh -c "echo nameserver ${nameserver} > /etc/resolv.conf"

    # and now some network namespace accounting
    mkdir -p /var/run/netns
    ln -sfT /proc/${pid}/ns/net /var/run/netns/${cname}
fi

if [ "${action}" = "down" ]; then
    path=$(echo "$@" | jq .bundle | sed 's%"%%g')
    veth_name_down=$(cat ${path}/.cube.veth)
    cname=$(basename ${path})

    ovs-vsctl del-port br-int ${veth_name_down}
    ip link del dev ${veth_name_down}

    # physical device passthrough
    if [ -n "${path}/.cube.device.network" ]; then
	# any non virtual ethernet devices ?
	netdevs=$(cat ${path}/.cube.device.network)
	for n in ${netdevs}; do
	    echo ${n} | grep -q veth
	    if [ $? -ne 0 ]; then
		# we have a real device
		device=$(echo ${n} | cut -f1 -d:)
		ip netns exec ${cname} ip link set ${device} netns 1
	    fi
	done
    fi

    # if pids are being tracked in our net namespace, make sure
    # we kill them before deleting it. Otherwise, the exit is not
    # clean
    if [ -f "${path}/.netns.pids" ]; then
	for pid in $(cat "${path}/.netns.pids"); do
	    kill -9 $pid
	done
    fi

    ip netns delete ${cname}
fi
